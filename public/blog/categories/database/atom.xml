<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: database | nathan leclaire]]></title>
  <link href="http://nathanleclaire.com/blog/categories/database/atom.xml" rel="self"/>
  <link href="http://nathanleclaire.com/"/>
  <updated>2014-09-29T03:20:27+00:00</updated>
  <id>http://nathanleclaire.com/</id>
  <author>
    <name><![CDATA[Nathan LeClaire]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Want to Work With Databases In Golang?  Let's Try Some gorp.]]></title>
    <link href="http://nathanleclaire.com/blog/2013/11/04/want-to-work-with-databases-in-golang-lets-try-some-gorp/"/>
    <updated>2013-11-04T18:58:00+00:00</updated>
    <id>http://nathanleclaire.com/blog/2013/11/04/want-to-work-with-databases-in-golang-lets-try-some-gorp</id>
    <content type="html"><![CDATA[<h1>Google&#8217;s Go</h1>

<p><a href="http://golang.org/">Go</a> is a new programming language released by <a href="http://www.google.com">Google</a>.  It has an excellent pedigree (see <a href="http://en.wikipedia.org/wiki/Rob_Pike">Rob Pike</a> and <a href="http://en.wikipedia.org/wiki/Ken_Thompson_%28computer_programmer%29">Ken Thompson</a>) and it brings a lot of interesting things to the table as a programming tool. Go has been the subject of rave reviews as well as controversy.  As Google is a web company it&#8217;s no surprise that Go seems hard-wired from the start to be used in the context of the modern web and the standard libaries include everything from <a href="http://golang.org/pkg/net/http/">HTTP servers</a> to <a href="http://golang.org/pkg/html/template/">a templating system</a> to address these ends.  A lot of companies and hobbyist hackers seem to enjoy Go as a utility language that replaces components which used to be written in Python or Perl (with Go offering better performance).</p>

<p>Its supporters emphasize its <a href="http://benchmarksgame.alioth.debian.org/u64q/benchmark.php?test=all&amp;lang=go&amp;lang2=yarv&amp;data=u64q">performance</a>, nifty approach to concurrency (it&#8217;s <a href="http://golang.org/doc/effective_go.html#concurrency">built right in</a>), and fast compile times as advantages.  Some of its detractors dislike its lack of exceptions and generics, but the purpose of this article is not to address these concerns, which have already been discussed <em>ad nauseum</em>.  Instead, this article will talk about and examine the <code>gorp</code> library.</p>

<p><img src="/images/gorp/gorp.jpeg" title="Eh?" ></p>

<p>I don&#8217;t actually mean GOOD OLD RAISINS &amp; PEANUTS, of course- I mean <a href="https://github.com/coopernurse/gorp">gorp</a>, an &#8220;ORM-ish library for Go&#8221;.  What is it, and how does it work its funny magic?</p>

<h1>ORM-ish?</h1>

<p>The README.md from <code>gorp</code>&#8217;s repository is just too great an introduction to not quote, check it out:</p>

<blockquote>
I hesitate to call gorp an ORM. Go doesn&#8217;t really have objects, at least not in the classic Smalltalk/Java sense. There goes the &#8220;O&#8221;. gorp doesn&#8217;t know anything about the relationships between your structs (at least not yet). So the &#8220;R&#8221; is questionable too (but I use it in the name because, well, it seemed more clever).

The &#8220;M&#8221; is alive and well. Given some Go structs and a database, gorp should remove a fair amount of boilerplate busy-work from your code.

I hope that gorp saves you time, minimizes the drudgery of getting data in and out of your database, and helps your code focus on algorithms, not infrastructure.
</blockquote>


<p>When I was looking into <a href="http://www.github.com/robfig/revel">Revel</a> as a possibility for a Go web application framework, I found myself frustrated by its lack of a database solution.  Persistence is just such a key aspect of web applications, and something that we&#8217;re so accustomed to letting frameworks take care of for us (a la Rails and Django) that it was hard to believe a large framework like Revel didn&#8217;t even want to touch the problem- especially since <a href="http://www.playframework.com/documentation/1.2.1/model">Play</a>, a large source of inspiration, provides such functionality.  Revel is awesome in a lot of other ways, like its code hotswap feature, but for now at least it is &#8220;bring-your-own-ORM&#8221; (or other database solution).</p>

<p>So I set off to look into this funny <code>gorp</code> business.  As it turns out, <code>gorp</code> is pretty straightforward and powerful.  At the time of writing, <code>gorp</code> can be used with MySQL, Sqlite3, and PostgreSQL (although there are some known issues that cause different drivers to behave slightly differently).</p>

<h1>Creating Tables</h1>

<p>The basic use case for <code>gorp</code> is to define some structs and then register them with an instance of <code>gorp</code>&#8217;s <code>DbMap</code> structure.  This structure is responsible for generating the raw SQL to perform basic database operations on a table that will mirror your custom defined structure.  <code>gorp</code> can easily create that table for you in the first place.  Check it out:</p>

<pre><code class="go">type Person struct {
    Id      int64    
    Created int64
    Updated int64
    FName   string
    LName   string
}

// connect to db using standard Go database/sql API
// use whatever database/sql driver you wish
db, err := sql.Open("mymysql", "tcp:localhost:3306*mydb/myuser/mypassword")

// construct a gorp DbMap
dbmap := &amp;gorp.DbMap{Db: db, Dialect: gorp.MySQLDialect{"InnoDB", "UTF8"}}

table := dbmap.AddTable(Person{}).SetKeys(true, "Id")
</code></pre>

<p>You can also use <code>AddTableWithName</code> if you don&#8217;t want the table name to be the same as the structure type&#8217;s name (in fact, <code>AddTable</code> calls <code>AddTableWithName</code>):</p>

<pre><code class="go">table := dbmap.AddTableWithName(Person{}, "People").SetKeys(true, "Id")
</code></pre>

<p>As you can imagine, being able to easily create and drop tables like this is useful for unit tests.</p>

<p>You can use structure field tags if you want to change the name of the columns in the actual SQL (let&#8217;s say your team has a convention to have only lowercase column names, but all members of a Go struct must be uppercase).  Additionally you can tell <code>gorp</code> to ignore fields completely with <code>db:"-"</code>:</p>

<pre><code class="go">type Person struct {
    Id       int64                        `id`
    Created  int64                        `created`
    Updated  int64                        `modified`
    FName    string                       `firstName`
    LName    string                       `lastName`
    Comments *SomeNonPersistentStructure  `db:"-"`
}
</code></pre>

<p>A seemingly undocumented feature is that you can set the size of the table columns manually.  If you don&#8217;t, <code>gorp</code> will automatically figure something out for you that may be a bit too large or too small.  For example, <code>gorp</code> turns this structure definition:</p>

<pre><code>// A Thing is a post (link submission or a comment)
type Thing struct {
    Id            int64
    Username      string
    Href          string
    Upvotes       int64
    Downvotes     int64
    Description   string
    ParentThingId int64
    Created       int64
    Updated       int64
}
</code></pre>

<p>into this (with default behavior / MySQL driver):</p>

<pre><code>+---------------+--------------+------+-----+---------+-------+
| Field         | Type         | Null | Key | Default | Extra |
+---------------+--------------+------+-----+---------+-------+
| Id            | bigint(20)   | YES  |     | NULL    |       |
| Username      | varchar(255) | YES  |     | NULL    |       |
| Href          | varchar(255) | YES  |     | NULL    |       |
| Upvotes       | bigint(20)   | YES  |     | NULL    |       |
| Downvotes     | bigint(20)   | YES  |     | NULL    |       |
| Description   | varchar(255) | YES  |     | NULL    |       |
| ParentThingId | bigint(20)   | NO   | PRI | NULL    |       |
| Created       | bigint(20)   | YES  |     | NULL    |       |
| Updated       | bigint(20)   | YES  |     | NULL    |       |
+---------------+--------------+------+-----+---------+-------+
</code></pre>

<p>When you call <code>gorp.DbMap.AddTableWithName</code>, it returns you a pointer to a <code>TableMap</code> struct that you can use to set the size of the columns.  So you think 255 characters is a bit long for a username?</p>

<pre><code>t1 := dbmap.AddTable(Person{}).SetKeys(true, "Id")
t1.ColMap("Username").SetMaxSize(25)
</code></pre>

<p>The things you learn from reading the unit tests (and digging in the <a href="https://github.com/robfig/revel/blob/master/samples/booking/app/controllers/gorp.go">Revel examples</a>), huh?</p>

<h1>CRUD</h1>

<p>Let&#8217;s take a look at what CRUD (Create-Read-Update-Delete) looks like using <code>gorp</code>-mapped structures.</p>

<p>Inserting a new row is simple (note that you have to declare the structs as pointers so that optional callback hooks can operate on your actual data instead of copies):</p>

<pre><code class="go">person := &amp;Person{
    Created: time.Now().UnixNow(), 
    Updated: time.Now().UnixNow(),
    FName: "Joe",
    LName: "Smith"
}
err := dbmap.Insert(person)
</code></pre>

<p>Want to select by primary key?</p>

<pre><code class="go">primaryKey := 1
p1, err := dbmap.Get(Person{}, primaryKey)
</code></pre>

<p>How about selecting by arbitrary (non-primary-key) fields?  You can use <code>dbm.Select</code> to get a slice, or <code>dbm.SelectOne</code> to populate the slice or structure with the revelant data.</p>

<pre><code class="go">var ids []int64
_, err := dbmap.Select(&amp;ids, "select id from Person")

lname = "LeClaire"
var person Person
err := dbmap.SelectOne(&amp;person, "select * from Person where LName=?", lname)
</code></pre>

<p>Update and delete work similarly :</p>

<pre><code class="go">// count is the # of rows updated / deleted
person.FName = "Nate" 
count, err := dbmap.Update(person)

// or just delete it 
count, err := dbmap.Delete(person)
</code></pre>

<h1>How does it do all of this crazy voodoo?</h1>

<p>Obviously gorp is really cool, and useful.  So how does it work?</p>

<p><img src="/images/gorp/use-the-source-luke.jpeg" title="Best way to learn." ></p>

<p>I had no idea, but I remembered the words of Jeff Atwood and other wise folks and cracked open the <a href="https://github.com/coopernurse/gorp/blob/master/gorp.go">source code on github</a>.  Reading the unit tests also proved useful in understanding how <code>gorp</code> should be used (one of the virtues of meticulously tested code - it documents).</p>

<p>Immediately upon cracking open the definition of <code>DbMap.AddTable</code> and <code>DbMap.AddTableWithName</code>, I had one of those &#8220;aha&#8221; moments that programmers know so well.</p>

<pre><code class="go">// AddTableWithName has the same behavior as AddTable, but sets
// table.TableName to name.
func (m *DbMap) AddTableWithName(i interface{}, name string) *TableMap {
        t := reflect.TypeOf(i)
        if name == "" {
                name = t.Name()
        }

        // check if we have a table for this type already
        // if so, update the name and return the existing pointer
        for i := range m.tables {
                table := m.tables[i]
                if table.gotype == t {
                        table.TableName = name
                        return table
                }
        }

        tmap := &amp;TableMap{gotype: t, TableName: name, dbmap: m}
        tmap.columns, tmap.version = readStructColumns(t)
        m.tables = append(m.tables, tmap)

        return tmap
}
</code></pre>

<p>Of course, it uses reflection!  Go&#8217;s <a href="http://golang.org/pkg/reflect/">reflect</a> package is what powers this manipulation and mapping of structure metadata (I wasn&#8217;t aware Go was capable of reflection when I started using <code>gorp</code>, so it was a bit of a surprise to find this out).</p>

<p>Suddenly everything became clearer to me and I feel like the code for <code>AddTableWithName</code> is fairly self-explanatory if you are familiar with the usage of the library.  The first part of the method deals with naming the table (user defined or based on the name of the structure).  The middle section checks to see if the table already is in existence and if so it updates the name (consequently, we can set up a table for a structure with one name, then change the table name later on if we want).  Lastly, it adds the table if it doesn&#8217;t exist and returns a pointer to the <code>TableMap</code> structure (we discussed this structure briefly earlier).</p>

<p>The code for the <code>readStructColumns</code> internal method that you see called near the end of the method is pretty cool as well, it powers <code>gorp</code>&#8217;s ability to deal with struct embedding (a pretty cool feature of the libary IMO).  I won&#8217;t reproduce it here, but if you are curious <a href="https://github.com/coopernurse/gorp/blob/master/gorp.go">go check it out</a>!</p>

<h1>The future</h1>

<p>Alas, we developers are never easy to please forever.  Here I will note some things that may become issues for users of <code>gorp</code>, and hopefully get the ball rolling on conversation about directions for <code>gorp</code>&#8217;s future development.</p>

<p>Support for <code>TEXT</code> columns (and maybe other, &#8220;weirder&#8221; column types like PostgreSQL&#8217;s <a href="http://www.postgresql.org/docs/9.2/static/datatype-json.html">json data type</a>) seems like something that will be needed to really bring <code>gorp</code> into the limelight as a robust and mature tool (see <a href="https://github.com/coopernurse/gorp/issues/34">this issue</a> on github, where someone brings up <code>TEXT</code> specifically).  A <code>VARCHAR</code> column arguably would be inappropriate for storing the content of a Reddit comment or a blog post, for example.  I&#8217;d be curious how the maintainers are interested in handling this- getting into defining custom data types with <code>gorp</code> (e.g. <code>gorp.Text</code>) might be dicey, for instance, or it could prove to be a robust solution.  In the long run, it&#8217;s worth considering how much of <code>gorp</code>&#8217;s flexibility and power comes from its ability to discern those kinds of things with minimal input from the user, and how much of that we&#8217;re willing to give up to have a VERY robust database / ORM-ish solution for Golang.</p>

<p>Other tough nuts to crack with <code>gorp</code> (Golang&#8217;s strict/static typing, which is definitely one of its advantages in some ways, is partially what makes some of these so challenging) :</p>

<ul>
<li>Handling relational data</li>
<li>Joins (the existing solution looks pretty workable, but feels a bit stiff - admittedly I haven&#8217;t tried it though)</li>
<li>Data migrations</li>
</ul>


<p>Any ideas?</p>

<p>Also, not to be &#8220;that guy&#8221;, but it could probably stand to be broken up into a few different files (one for each of the different structures, for instance) instead of one large <code>gorp.go</code> file.</p>

<h1>Conclusion</h1>

<p><code>gorp</code> is a very cool, if still young, tool / library.  I find it to be a good combination of abstraction and practicality.  What do you think?</p>

<p>Thanks for reading, I&#8217;ll see you next week.</p>

<p>Nate</p>
]]></content>
  </entry>
  
</feed>
