<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: binary tree | nathan leclaire]]></title>
  <link href="http://nathanleclaire.com/blog/categories/binary-tree/atom.xml" rel="self"/>
  <link href="http://nathanleclaire.com/"/>
  <updated>2014-09-29T03:13:10+00:00</updated>
  <id>http://nathanleclaire.com/</id>
  <author>
    <name><![CDATA[Nathan LeClaire]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Build a Linked List For Each Layer in a Binary Tree]]></title>
    <link href="http://nathanleclaire.com/blog/2014/03/01/build-a-linked-list-for-each-layer-in-a-binary-tree/"/>
    <updated>2014-03-01T15:52:00+00:00</updated>
    <id>http://nathanleclaire.com/blog/2014/03/01/build-a-linked-list-for-each-layer-in-a-binary-tree</id>
    <content type="html"><![CDATA[<p><img src="/images/linkedListTree/binary_tree.png"></p>

<p>I&#8217;ve been going through problems in <a href="http://www.amazon.com/Cracking-Coding-Interview-Programming-Questions/dp/098478280X">Cracking the Coding Interview</a> to keep my chops strong and for giggles and this one took a little bit of wrangling for me to get:</p>

<blockquote><p>Given a binary search tree, design an algorithm which creates a linked list of all the
nodes at each depth (i e , if you have a tree with depth D, youâ€™ll have D linked lists)</p></blockquote>

<p>So a binary tree such as :</p>

<pre>
       (1)
      /   \
     /     \
   (2)     (3)
  /  \     / \
(4)  (5) (6) (7)
</pre>


<p>Will return linked lists:</p>

<pre>
(1) => NULL
(2) => (3) => NULL
(4) => (5) => (6) => (7) => NULL
</pre>


<p>I wrote up my solution to this in Python, and I&#8217;m going to share it with you to study and critique.</p>

<h1>Solution</h1>

<h2>The Linked List Implementation</h2>

<p>If you&#8217;ve ever seen or written a linked list implementation before, you&#8217;ll probably realize there&#8217;s nothing particularly brilliant or innovative about this one.  Just a good old-fashioned, simple singly linked list.</p>

<pre><code class="python">class LinkedList:
    next = None
    val = None

    def __init__(self, val):
        self.val = val

    def add(self, val):
        if self.next == None:
            self.next = LinkedList(val)
        else:
            self.next.add(val)

    def __str__(self):
        return "({val}) ".format(val=self.val) + str(self.next)
</code></pre>

<p>Usage:</p>

<pre><code class="python">ll = LinkedList(1)
ll.add(2)
ll.add(3)
</code></pre>

<h2>The Binary Tree Implementation</h2>

<p>The binary tree implementation is similarly from scratch, and simlarly simple.</p>

<pre><code class="python">class BinaryTree:
    val = None
    left = None
    right = None

    def __init__(self, val):
        self.val = val

    def __str__(self):
        return "&lt;Binary Tree (val is {val}). \n\tleft is {left} \n\tright is {right}&gt;".format(val=self.val, left=self.left, right=self.right)
</code></pre>

<p>No methods, I do all of the tree manipulation by hand.  This works okay for problems of this (considerably small) scale.</p>

<h2>The Algorithm</h2>

<p>The algorithm that I came up with is actually slightly different than what is listed as the solution in the book, and depends a bit of idiosyncracies of Python that aren&#8217;t in Java (which all of the solutions from the book are written in).  Namely, it uses optional arguments to avoid wrapper methods and it uses a dictionary instead of a <code>ArrayList&lt;LinkedList&lt;BinaryTree&gt;&gt;</code>.</p>

<p>I also differ from the solution in the book in that I grab the depth of the tree once and use that to determine the linked list&#8217;s index, which is slightly less efficient than the solution that they provide.  If I&#8217;m not mistaken, however, the asymptotic complexity is still the same (<code>O(n)</code>).</p>

<p>My depth function is exactly what you&#8217;d expect (recursive):</p>

<pre><code class="python">def depth(tree):
    if tree == None:
        return 0
    if tree.left == None and tree.right == None:
        return 1
    else:
        depthLeft = 1+depth(tree.left)
        depthRight = 1+depth(tree.right)
        if depthLeft &gt; depthRight:
            return depthLeft
        else:
            return depthRight
</code></pre>

<p>My <code>tree_to_linked_lists</code> function does a <a href="http://en.wikipedia.org/wiki/Tree_traversal#Pre-order">pre-order traversal</a>, adding nodes to their corresponding linked list (based on depth) in the dictionary <code>lists</code> as the tree is traversed.  <code>lists</code> is passed into, and returned from (in its mutated state), each call to <code>tree_to_linked_lists</code>.</p>

<pre><code class="python">def tree_to_linked_lists(tree, lists={}, d=None):
    if d == None:
        d = depth(tree)
    if lists.get(d) == None:
        lists[d] = LinkedList(tree.val)
    else:
        lists[d].add(tree.val)
        if d == 1:
            return lists
    if tree.left != None:
        lists = tree_to_linked_lists(tree.left, lists, d-1)
    if tree.right != None:
        lists = tree_to_linked_lists(tree.right, lists, d-1)
    return lists
</code></pre>

<p>This produces a result that is sort of in reverse order compared to the solution provided by the book, but it still satisfies the problem description to provide a collection of linked lists.</p>

<h1>Conclusion</h1>

<p>You can find the entirety of the code <a href="https://gist.github.com/nathanleclaire/9292861">here</a>.</p>

<p>I need to be better at data structures and algorithms.  They are fun.</p>

<p>Until next time, stay sassy Internet.</p>

<ul>
<li>Nathan</li>
</ul>

]]></content>
  </entry>
  
</feed>
