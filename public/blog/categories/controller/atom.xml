<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: controller | nathan leclaire]]></title>
  <link href="http://nathanleclaire.com/blog/categories/controller/atom.xml" rel="self"/>
  <link href="http://nathanleclaire.com/"/>
  <updated>2014-09-29T03:13:10+00:00</updated>
  <id>http://nathanleclaire.com/</id>
  <author>
    <name><![CDATA[Nathan LeClaire]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[5 AngularJS Antipatterns & Pitfalls]]></title>
    <link href="http://nathanleclaire.com/blog/2014/04/19/5-angularjs-antipatterns-and-pitfalls/"/>
    <updated>2014-04-19T13:58:00+00:00</updated>
    <id>http://nathanleclaire.com/blog/2014/04/19/5-angularjs-antipatterns-and-pitfalls</id>
    <content type="html"><![CDATA[<h1>The Angular Jungle</h1>

<p><img src="/images/angular-antipatterns/jungle.jpg"></p>

<p><a href="http://angularjs.org">AngularJS</a> is a big JavaScript framework and it gives you just enough rope to hang yourself with.  I&#8217;ve written a lot about it in this blog and really hope that I have made a noteworthy impact on improving the general availability of resources.  I&#8217;ve been working on a project using AngularJS at my dayjob lately and noticed some antipatterns and pitfalls that people fall into when they are new to Angular (myself included, so they&#8217;re based on my own sweat and blood learning the framework) and I&#8217;ve consolidated some of them here for you to peruse.  Hopefully I&#8217;ll save you some pain.</p>

<p>They are:</p>

<ol>
<li>Not having a dot in your <code>ng-model</code> (or other places you need it!)</li>
<li>Extreme overuse of event broadcasting and listening (<code>$emit</code>, <code>$broadcast</code>, <code>$on</code>)</li>
<li>Too much stuff in controllers</li>
<li>Misunderstanding or misusing isolate scope</li>
<li>Using the outside world instead of doing things the Angular way</li>
</ol>


<h1>1. Not having a dot in your <code>ng-model</code> (or other places you need it!)</h1>

<p><img src="/images/angular-antipatterns/george.jpg"></p>

<p>Angular&#8217;s <a href="https://docs.angularjs.org/guide/directive">directives</a> provide fantastic flexibility and an amazing way to write HTML that describes its interactive behavior in a clean and clear fashion.  They provide a way to create <a href="https://egghead.io/lessons/angularjs-understanding-isolate-scope">isolate scope</a> to promote reusability and creating a directive that uses this looks something like:</p>

<pre><code class="js">angular.module('myApp').directive('myDir', function () {
  return  {
    restrict: 'E',
    scope: {
      aProperty: '=',
      bProperty: '&amp;'
    },
    // and so on...
  };
});
</code></pre>

<p>In the above definition <code>aProperty</code> gets passed in through an attribute (normalized to <code>a-property</code>) and creates a two-way data binding between the parent scope and the child scope.  That means if you change one, the other will be updated to match it and vice versa.  However, because of the way that JavaScript&#8217;s prototypal inheritance works, sometimes this may not work &#8220;magically&#8221; as you would expect.  I will dicuss a particular situation with <code>ng-model</code> here but know that understanding how this all ties together will save you lots of tears due to <code>ng-switch</code>, <code>ng-repeat</code>, etc. creating their own scopes (and &#8220;shadow&#8221; properties in the prototype chain) that throw off the way you might be expecting things to work.</p>

<p>In particular, when you have an <code>ng-model</code> bound to a property on <code>$scope</code> which was originally passed in using <code>=</code> in your child directive:</p>

<blockquote><p>“Whenever you have ng-model there’s gotta be a dot in there somewhere. If you don’t have a dot, you’re doing it wrong.”</p></blockquote>

<p>Words from the mouth of Miško himself.</p>

<p>This is because <em>primitives</em> (String, Number, etc.) passed in to a child scope create their own &#8220;shadow&#8221; property in the child scope, which hides the original property on the parent scope due to the way that JavaScript prototypes work (the prototype chain will not need to be consulted to determine the value of <code>foo</code> if <code>foo</code> is not an <code>Object</code> or <code>Array</code>).  If they are bound using <code>=</code> and they are objects, however, <code>foo.bar</code> <em>will</em> be bound correctly to the original property in the parent scope.</p>

<p>Understanding this will save you soooo much pain.  Seriously, if you&#8217;re serious about Angular at all, take the time to read the offical article I link at the end of this section.  Then read it again.</p>

<p>I suspect that a misunderstanding of this (communicating effectively from scope to scope up and down the prototype chain) is at least partially what contributes to people digging themselves further and further into a hole by misusing event broadcasting/emitting/listening and isoalte scope, as detailed later on in this article.  When things spiral out of control in this manner, it can really be pure torture.  You&#8217;re fighting against the framework, and nobody wins in that battle, least of all the people who have to maintain your code.</p>

<p>The point is, most people new to Angular (and even people who have been doing it for a while) expect this to work :</p>

<p>
&#8220;`</p>

<p> You have {{dollars}} dollars </p>


<p><crazy-awesome-widget ng-repeat="account in accounts" info="dollars">
</crazy-awesome-widget></p>

<script>
angular.module('dotDemo').controller('OuterCtrl', function($scope) {
  $scope.dollars = 5;
  $scope.accounts = ["Tom", "Bobby", "Sally"];
});
angular.module('dotDemo').directive('crazyAwesomeWidget', function() {
  return {
    restrict: 'E',
    template: '<input type="text" ng-model="info" />',
    scope: {
      info: '='
    }
  };
});
</script>


<p>&#8220;`
</p>

<p>Can you spot the bug?  If you&#8217;ve been paying attention, you should be able to pick it out easily.</p>

<iframe src="http://embed.plnkr.co/ii8xZoOIRcWw4LlNMayf/preview"></iframe>


<p>Come on, intone it with me.  <em>I need a dot. I need a dot. I need a dot.</em></p>

<p>In the above code the input boxes won&#8217;t update the property in the parent scope.  The prototype chain creates a new property <code>info</code> which is unique to the child scope instead of bound to the parent scope.  It won&#8217;t work this way.  You need an object.  The code should look like this instead:</p>

<p>
&#8220;`</p>

<p> You have {{customerData.dollars}} dollars </p>


<p><crazy-awesome-widget ng-repeat="account in accounts" info="customerData">
</crazy-awesome-widget></p>

<script>
angular.module('dotDemo').controller('OuterCtrl', function($scope) {
  $scope.customerData = {
    dollars: 5
  };
  $scope.accounts = ["Tom", "Bobby", "Sally"];
});
angular.module('dotDemo').directive('crazyAwesomeWidget', function() {
  return {
    restrict: 'E',
    template: '<input type="text" ng-model="info.dollars" />',
    scope: {
      info: '='
    }
  };
});
</script>


<p>&#8220;`
</p>

<iframe src="http://embed.plnkr.co/IVkqcNVhwQXd1zQ9nZQ2/preview"></iframe>


<p>Boom, synchronization from parent scope => isolated child scopes and back again.</p>

<p>Big shout out to Reddit user <a href="http://www.reddit.com/user/Commentares">Commentares</a> who caught a flaw in the original implementation of my first example in the first draft of this article.</p>

<p>See for reference:</p>

<ul>
<li><a href="http://jimhoskins.com/2012/12/14/nested-scopes-in-angularjs.html">This excellent article by Jim Hoskins</a></li>
<li><a href="https://github.com/angular/angular.js/wiki/Understanding-Scopes">This aforementioned Angular documentation gettin&#8217; mad deep about scopes</a></li>
</ul>


<h1>2. Extreme overuse of event broadcasting and listening (<code>$emit</code>, <code>$broadcast</code>, <code>$on</code>)</h1>

<p>Everybody loves to hate on GOTOs.  Poor little GOTOs.  All they ever wanted to do was help control program execution flow and branching, and they get the Rodney Dangerfield treatment.  They&#8217;re reviled with that sort of knee-jerk reaction that only programmers can revile something with.  You know the type.  They&#8217;re the ones who got burned by <code>git rebase</code> one time (it was their own fault) and spend way too much effort and energy spreading FUD about rebases.  But I digress.  My point is, there&#8217;s this Angular antipattern I&#8217;ve seen and fallen into, where <code>$scope.$emit</code> and <code>$scope.$broadcast</code> have become the new GOTO.  Except that it&#8217;s shiny and new and Angular-ey, so everybody gives it a pass.  <code>$scope.$watch</code> can kind of be abused in the same way, but the others are slightly easier to pick on.</p>

<p>I really feel that you should keep manual event broadcasting and catching out of your code if possible.  It doesn&#8217;t usually do a whole lot of good and confuses the hell out of the people who have to maintain your code (including you!).  The problem is thus:  Let&#8217;s say you have something going wacky in a <code>$scope.$on</code>.  You set a breakpoint in the defined callback function that runs when that <code>$scope.$on</code> catches its defined event.  OK, now what?  Perhaps you look to see where the event was thrown from.  With constrained eventing, debugging shouldn&#8217;t be a problem, but if you or your team lets their discipline slip into event spaghetti you&#8217;re in for a world of pain.  Usually this can be avoided by careful use of services and proper scope inheritance.</p>

<h1>3. Too much stuff in controllers</h1>

<p>It&#8217;s unfortunate that I have to point this one out, but as I&#8217;ve personally fallen into this pitfall especially when first getting started with Angular, I suppose I can give people a free pass on making this mistake once or twice.  After that, however, they should definitely learn.</p>

<p>Your controllers should be lean.  Say it with me.</p>

<p>My controllers should be lean.</p>

<p>My controllers should be lean.</p>

<p>My controllers <em>are</em> lean.</p>

<p>This means that absolutely everything which can be stripped out of them, should be.  They exist to coordinate the delicate dance between your other resources (services and directives).</p>

<p>For instance, I came across a line introduced in one of our controllers that looked like this:</p>

<pre><code>$('body').attr('data-state', 'someNewState');
</code></pre>

<p>This was my reaction upon finding this code in this controller:</p>

<p><img src="/images/angular-antipatterns/hulk.gif"></p>

<p>Note:  My actual reaction was way more passive aggressive (wrote about it in my <em>blog</em>!  Showed that guy).</p>

<p>In Angular, DOM manipulation is done inside directives.  NOT controllers.  DOM manipulation is done inside directives.  Every aspiring Angular programmer should have this branded into his or her brain.</p>

<p>Other common things that slip into controllers:</p>

<ul>
<li>Ajax (sometimes disguised in a half-baked abstraction) - this should be done in services</li>
<li>Tangled mess of event handling as discussed in last section</li>
<li>Things that are basically service or factory logic, but eh I&#8217;m too lazy to move this code</li>
</ul>


<p>Don&#8217;t do it.  If you keep your controllers lean and small they will reward you with readability and ease of debugging.  If you let them spiral out of control you will be punished unceremoniously.</p>

<h1>4. Misunderstanding or misusing isolate scope</h1>

<p>Isolate scope is really nice.  It prevents directives from just accessing / modifying the parent scope willy-nilly, opening the door to all kinds of bugs associated with global-ish scope, and promotes reusability.  But it&#8217;s important to realize that this is the point of isolate scope.  Consequently, if you&#8217;re passing a bunch of properties into your directive&#8217;s <code>$scope</code>, and then cascading them downwards through a variety of child scopes, you are probably doing something wrong.</p>

<p>I&#8217;ve seen this a bit.  If you are passing a bunch of information down to your directive&#8217;s scope, either it should be inheriting by default (in which case you don&#8217;t want isolate scope), or you should bundle the properties that you can together in an object or two to keep the <code>scope</code> definition nice and clean and promote readability of the HTML.</p>

<h1>5. Using the outside world instead of doing things the Angular way</h1>

<p><img src="/images/angular-antipatterns/but-computers.png" title="Aren&#8217;t we all nowadays?" ></p>

<p>It&#8217;s really tempting, especially when first learning Angular, and directives in particular, to just write jQuery code like we always have that happens to be wrapped in an Angular directive.  While this is still probably better than rolling with no framework at all and creating a tangled mess, it indicates a basic ungrok of the Angular way.</p>

<p>Things should be done in Angular, when they can.  Angular provides so much niceness in the form of built-in directives, services (<code>$window</code>, <code>$timeout</code>, <code>$http</code> et al. wrap these things for you so you don&#8217;t have to worry about accidentally interfering with Angular&#8217;s internals!) that we should only reach for custom solutions when we have to (and believe me, you will - just think carefully before doing so).  Just wrapping jQuery code in a directive doesn&#8217;t do us any good, and creates complications when we need to start doing stuff like chucking <code>$scope.$apply</code> into things.  So think things through, and do them the Angular way.</p>

<p>Likewise dependencies that you had before (modules you are relying on etc.) should be refactored into e.g. factories for increased ease of use and testability.  If you have the time to use Angular into your project, you have the time to do this too.  Angular will reward you with layers of increased richness.</p>

<h1>Fin</h1>

<p>I really hope that this article helps people avoid these bad behaviors, or at least see them when they come across them and refactor them into something better.</p>

<p>Until next time, stay sassy Internet.  And <a href="http://nathanleclaire.com">consider subscribing to my mailing list</a>.</p>

<ul>
<li>Nate</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AngularJS isn't MVC, it's SDC]]></title>
    <link href="http://nathanleclaire.com/blog/2014/03/15/angularjs-isnt-mvc-its-sdc/"/>
    <updated>2014-03-15T12:38:00+00:00</updated>
    <id>http://nathanleclaire.com/blog/2014/03/15/angularjs-isnt-mvc-its-sdc</id>
    <content type="html"><![CDATA[<h1>Intro</h1>

<p><img src="/images/notmvc/angular-homepage-old.gif"></p>

<p>I first started learning AngularJS because I was interested in exploring the world of MV&#42; JavaScript frameworks for the client side.  There was something intruiging and exciting happening about a year or two ago in that space, as several JS frameworks started to get some steam and critical mass and the mainstream of client-side development (even those boring <a href="http://www.hanselman.com/blog/501DevelopersFamilyAndExcitementAboutTheCraft.aspx">5:01 developers</a> couldn&#8217;t ignore the zeitgeist anymore) seemed to wake up and realize that maybe there was a need for something more than just vanilla jQuery in applications where everything was spiraling way out of control.</p>

<p>So I started looking into Angular for the myriad reasons you usually hear people cite as a reason for using it.  It was backed by Google.  It was easy to get going quickly.  The quality of documentation and tutorials, though not fantastic, was starting to improve relative to Ember or more obscure frameworks.  It was fun.</p>

<p>My first foray went down in flames.</p>

<p><img src="/images/notmvc/javascript.png"></p>

<p>I fell into a common Angular antipattern (I may discuss Angular antipatterns more in a future article) where I stuffed everything into the controller.  Services and directives looked a little scary, and required learning esoteric things like what the meaning of <code>@</code>, <code>&amp;</code>, and <code>=</code> was in a directive, and instead I saw fit to simply stuff everything into <code>$scope</code> and coordinate activities using event broadcasting and listening.</p>

<p>That project became so un-fun to work on that I just stopped.  I had dug myself into a hole deeper than I would ever get out of without a complete rewrite.</p>

<p>Fortunately, partially through writing about Angular a lot, I eventually wised up.</p>

<p>I learned that Angular is structured in some ways that are similar to what we have experienced before, but it also hearkens a little bit to the future of the client side (see <a href="http://www.w3.org/TR/components-intro/">Web Components</a>).  And because of that, it had a little bit of new stuff too that threw me.</p>

<p>You may be used to the Model View Controller pattern- but that&#8217;s not what Angular is.   A subsection of it kind of looks like that, but if you take a step back you will see a bigger picture emerge.</p>

<p>Angular is Service, Directive, Controller.</p>

<h1>The Angular Way</h1>

<p>Angular is all about testability, and testability mandates that we be able to break our application into components.  In most cases, monoliths are considered harmful.  You probably understand why if you&#8217;ve ever worked on one.  Things become too brittle and easy to break.  They become tightly coupled.  It&#8217;s impossible to change codes without introducing bugs in unrelated places.  And so on.</p>

<p>Angular draws lines between separate parts of the architecture so that you can avoid many of these headaches.  In particular, dependency injection treats us well, as we rely on Angular&#8217;s injector to provide us with the things that we need instead of getting them ourselves.  This also allows us more control over how they are provided, which eases testing significantly (the developer has a smaller surface area that he needs to control).</p>

<p>Most applications use these underlying principles to do three things: Retrieve, process, or send out data (usually communicating with the &#8220;outside world&#8221; such as a database or API), present (display) that data to the user in a useful way, and coordinate the general state of the application (this includes features such as routing).</p>

<p>The first things that we mentioned, handling data, is the job of services.</p>

<h2>Services</h2>

<p>The main point of services is to dictate how data flows into or out of your application, not within it.  If you are talking to the outside world, this is a perfect use case for a service.  Controllers use methods and data provided by these services to update properties on <code>$scope</code>, which in turn dictates how the DOM changes when a new digest cycle hits.</p>

<p>When I was new to Angular, I flubbed this.  In particular the difference between <a href="http://stackoverflow.com/questions/15666048/angular-js-service-vs-provider-vs-factory">services and factories</a> wasn&#8217;t clear to me, so I avoided them.  Instead I made <code>$http</code> calls inside of my controllers, which ended up turning my controllers into a confused mess of business and application logic.</p>

<p>This is <em>NOT</em> the way to go.  Instead, anything that involves setting, retrieving, or processing data should happen in services.  The leaner that your controllers are, the better.</p>

<p>Services should NEVER manipulate <code>$scope</code>.  That is the job of the controller.  If you need to change values in <code>$scope</code> based on the result of, say, an AJAX call, use <a href="http://docs.angularjs.org/api/ng/service/$q">promises</a>.  Check out <a href="http://nathanleclaire.com/blog/2014/01/04/5-smooth-angularjs-application-tips/">this blog article I wrote</a> for more details.</p>

<h2>Directives</h2>

<p>Directives are definitely one of the most confusing parts of AngularJS to a newcomer.  The prospect of writing your own is intimidating.  Especialy when I first started learning, the quality of available documentation and tutorials for them was not very high (this has improved a lot in the last year or so though).</p>

<p>But directives, for all that they intimidate the newbie, promise a land of amazing power.  Most people who are coming to Angular from a jQuery way of thinking run the risk of getting themselves in trouble by performing DOM manipulation outside of directives.  They are so used to the old way of doing things, where an element can be accessed willy-nilly by any piece of client side code that needs it.</p>

<p>Directives have several different forms but usually they are either completely new HTML elements, or attributes that you can throw on existing elements, to perform some kind of DOM manipulation.  They can have their own scope and they can be reused, which is one of their most useful properties.</p>

<p>In some ways we are all still fighting our way towards manifesting in reality the Platonic ideal of what directives represent, e.g. I should never have to rewrite a calendar widget if it is already existing, I should just be able to use a <code>&lt;calendar&gt;&lt;/calendar&gt;</code> element and set properties to customize it the way that I like.  But in other ways this <em>is</em> approaching reality, especially as Angular grows in popularity and as systems such as Bower become more useful and flexible.</p>

<p>Directives promise no more spaghetti jQuery code (do they deliver?).  Instead, everything gets broken out into modular components that are far easier to test.</p>

<h2>What about Views?</h2>

<p>In a lot of ways the &#8220;view&#8221; is the same as it&#8217;s ever been, modulo directives which we have already discussed.  <code>ngView</code> promises new, snappy navigation, which is exciting.  Views in AngularJS do the same job they always have and they do it well.  Technically I probably should have called this article &#8220;Angular isn&#8217;t MVC, it&#8217;s SDVC&#8221; but I didn&#8217;t think it had the same ring to it.</p>

<h2>Controllers</h2>

<p>Finally we discuss the piece that ties it all together.  The controller.</p>

<p>Without controllers, directives are useless.  Controllers set properties on <code>$scope</code> for directives to use.</p>

<p>Likewise, without controllers, services are useless.  They are just objects for playing with data.  Therefore controllers are like the &#8220;glue&#8221; of your application.</p>

<p>Controllers should be as lean and lightweight as possible.  It makes it easier to see what&#8217;s going on, and it makes it easier to test them.</p>

<h1>Conclusion</h1>

<p>Angular is a new framework and it requires a new way of thinking.  Trying to apply the old patterns, or being inflexible and unwilling to learn about the different components of Angular and how they fit together will get you in trouble.</p>

<p>Everyone likes jQuery because jQuery is a useful tool.  It is simple and it allows you to build whatever you want.  It isn&#8217;t very opinionated about the way you do so (in fact it provides you with a lot of options).</p>

<p>Angular, on the other hand, is like a house.  It already has a framework and a foundation for how to do things, you just have to furnish it.  Trying to use Angular like a hammer will only result in tears.  It is like trying to use a house to build a house.</p>

<p>I hope that this essay may help to clear some things up to people who are new to Angular.</p>

<p>Until next week, stay sassy Internet.</p>

<ul>
<li>Nathan</li>
</ul>

]]></content>
  </entry>
  
</feed>
