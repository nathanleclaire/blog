<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: go | nathan leclaire]]></title>
  <link href="http://nathanleclaire.com/blog/categories/go/atom.xml" rel="self"/>
  <link href="http://nathanleclaire.com/"/>
  <updated>2014-09-29T03:20:27+00:00</updated>
  <id>http://nathanleclaire.com/</id>
  <author>
    <name><![CDATA[Nathan LeClaire]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Why codegangsta's cli package is the bomb, and you should use it]]></title>
    <link href="http://nathanleclaire.com/blog/2014/08/31/why-codegangstas-cli-package-is-the-bomb-and-you-should-use-it/"/>
    <updated>2014-08-31T06:18:50+00:00</updated>
    <id>http://nathanleclaire.com/blog/2014/08/31/why-codegangstas-cli-package-is-the-bomb-and-you-should-use-it</id>
    <content type="html"><![CDATA[<h1>go go go</h1>

<p><img src="/images/cli/codegangsta.png" title="Blowing other gangsters (and coders) to smithereens." ></p>

<p>This week I&#8217;m writing an opinion piece on why I think that <a href="https://github.com/codegangsta/cli">codegangsta</a>&#8217;s command line interface package for Golang is great, and you should use it.  Nice job, contributors!</p>

<p>The reasons are:</p>

<ol>
<li>Well designed, and a pleasure to use</li>
<li>Lets you get stuff done</li>
<li>Flags are how they&#8217;re meant to be</li>
<li>Well documented</li>
<li>Friendly community</li>
</ol>


<h2>Well designed, and a pleasure to use</h2>

<p>This is the library that you dreamed about when you first learned how to use <code>argv</code> and <code>argc</code> in C.  If you&#8217;ve ever tried parsing <code>argv</code> by hand (without relying on an external library), you know that it can be a pain and require a lot of strenuous fixing up with duct tape in order to get working effectively.  Well no more now.  Just:</p>

<ul>
<li><code>import "github.com/codegangsta/cli"</code></li>
<li>get an instance of <code>cli.App</code></li>
<li>set actions and usage, and quickly get to making the thing you set out to!!</li>
</ul>


<p>As evidenced by the popularity of <a href="https://github.com/codegangsta/martini">Martini</a> and <a href="https://github.com/codegangsta/negroni">Negroni</a>, codegangsta has good taste when it comes to designing APIs for developers to consume.  I&#8217;ve used <code>cli</code> for a variety of things now, and it&#8217;s very flexible while still be incredibly effective.</p>

<p>I mean come on, this just <em>looks</em> incredibly fun:</p>

<pre><code>/* greet.go */
package main

import (
  "os"
  "github.com/codegangsta/cli"
)

func main() {
  app := cli.NewApp()
  app.Name = "greet"
  app.Usage = "fight the loneliness!"
  app.Action = func(c *cli.Context) {
    println("Hello friend!")
  }

  app.Run(os.Args)
}
</code></pre>

<p>And gives you stuff like <em>this</em>:</p>

<pre><code>$ greet help
NAME:
    greet - fight the loneliness!

USAGE:
    greet [global options] command [command options] [arguments...]

VERSION:
    0.0.0

COMMANDS:
    help, h  Shows a list of commands or help for one command

GLOBAL OPTIONS
    --version   Shows version information
</code></pre>

<p>From the manual:</p>

<blockquote><p>cli.go also generates some bitchass help text:</p></blockquote>

<p>+1</p>

<h2>Lets you get stuff done</h2>

<p>I sort of hinted at this, but this is what I see as the main advantage of <code>cli</code> over using nothing, or just using raw <code>flag</code> parsing, it allows you to handle the inevitable complexity of developing a command line application before it even becomes an issue.</p>

<p>I&#8217;ve long noticed that developers love libraries the most when you barely even notice they&#8217;re there.  The framework or tool becomes like an extension of your own mind in solving the problem.  In my opinion, jQuery is like this.  It inspires such a raw explosion of creativity in the people using it that its explosion and proliferation was inevitable.  Instead of making you cobble together vanilla JavaScript to get what you want, you can work way further up in many different ways which are <em>all right</em>.  Go is like that too, with <code>gofmt</code> and Go&#8217;s error handling patterns etc. at play everyone&#8217;s code starts to look the same.</p>

<p>That&#8217;s what <code>cli</code> is like.  It just gets out of the way, and lets you write the application that you actually came here to write.</p>

<h2>Flags are how they&#8217;re meant to be</h2>

<p>I have to admit, I <em>LOVE</em> flags.  I grew up on a steady diet of UNIX weirdness and writing apps that have crazy flag fun is fantastic.  <code>cli</code>&#8217;s API is easy to follow.  Even a complicated structure retains order.  For instance, a sample from a rewrite of <a href="fig">fig</a> in Go that I&#8217;ve been doing:</p>

<pre><code class="go">// global level flags
app.Flags = []gangstaCli.Flag{
    gangstaCli.BoolFlag{
        Name:  "verbose",
        Usage: "Show more output",
    },
    gangstaCli.StringFlag{
        Name:  "f, file",
        Usage: "Specify an alternate fig file (default: fig.yml)",
    },
    gangstaCli.StringFlag{
        Name:  "p, project-name",
        Usage: "Specify an alternate project name (default: directory name)",
    },
}

// Commands
app.Commands = []gangstaCli.Command{
    {
        Name: "build",
        Flags: []gangstaCli.Flag{
            gangstaCli.BoolFlag{
                Name:  "no-cache",
                Usage: "Do not use cache when building the image.",
            },
        },
        Usage:  "Build or rebuild services",
        Action: CmdBuild,
    },
    // etc...
    {
        Name: "run",
        Flags: []gangstaCli.Flag{
            gangstaCli.BoolFlag{
                Name:  "d",
                Usage: "Detached mode: Run container in the background, print new container name.",
            },
            gangstaCli.BoolFlag{
                Name:  "T",
                Usage: "Disables psuedo-tty allocation. By default `fig run` allocates a TTY.",
            },
            gangstaCli.BoolFlag{
                Name:  "rm",
                Usage: "Remove container after run.  Ignored in detached mode.",
            },
            gangstaCli.BoolFlag{
                Name:  "no-deps",
                Usage: "Don't start linked services.",
            },
        },
        Usage:  "Run a one-off command",
        Action: CmdRm,
    },

    {
        Name: "up",
        Flags: []gangstaCli.Flag{
            gangstaCli.BoolFlag{
                Name:  "watch",
                Usage: "Watch build directory for changes and auto-rebuild/restart",
            },
            gangstaCli.BoolFlag{
                Name:  "d",
                Usage: "Detached mode: Run containers in the background, print new container names.",
            },
            gangstaCli.BoolFlag{
                Name:  "k,kill",
                Usage: "Kill instead of stop on terminal stignal",
            },
            gangstaCli.BoolFlag{
                Name:  "no-clean",
                Usage: "Don't remove containers after termination signal interrupt (CTRL+C)",
            },
            gangstaCli.BoolFlag{
                Name:  "no-deps",
                Usage: "Don't start linked services.",
            },
            gangstaCli.BoolFlag{
                Name:  "no-recreate",
                Usage: "If containers already exist, don't recreate them.",
            },
        },
        Usage:  "Create and start containers",
        Action: CmdUp,
    },
}
</code></pre>

<p>It always drove me crazy that Golang&#8217;s default <code>flag</code> package preferred <code>-name</code> style (one hyphen) flags  by default, although there may be a good reason for it that I&#8217;m not aware of.  <code>cli</code> does <code>--long-flags</code> this way by default.  Yay!</p>

<p>It supports multiple forms of flags (e.g. <code>-v</code> and <code>--verbose</code>).  You get subcommands too (e.g. <code>git remote add</code>, <code>git remote rm</code>).  It&#8217;s an incredible amount of power and flexibility.</p>

<h2>Well documented</h2>

<p>I was able to divine pretty much everything I needed to write an effective app with this library quite easily from the documentation.  &#8216;Nuff said.  That&#8217;s a rare honor in this world of half-baked Github repos, Gists, and JSFiddles.</p>

<h2>Friendly community</h2>

<p>codegangsta and crew are pretty active on Github (and I would guess IRC, but I don&#8217;t know this for a fact).  Proposals for new features and the like are not met with hostility on Github, instead they are discussed with civility.  I hate seeing Github issues devolve into flame wars and I definitely think community matters a lot in weeding out the bad actors to keep the experience of discussing software a pleasurable one.</p>

<h1>What are the downsides?</h1>

<p>Like anything new, <code>cli</code> has a few downsides too.</p>

<ul>
<li><a href="https://github.com/codegangsta/cli/issues/56">this bug about the flag parsing terminator (<code>--</code>)</a></li>
<li>Performance (probably not a concern for most apps)</li>
<li>Still early in development</li>
</ul>


<p>In spite of these issues, obviously I think <code>cli</code> is really great for getting applications out the door quickly with Go.  I am hopeful that its great design and philosophy will influence future libraries, frameworks, and software.  :thumbsup:</p>

<h1>Fin.</h1>

<p>I like this library.  Use it.</p>

<p>Until next time, stay sassy Internet.</p>

<ul>
<li>Nathan</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Demystifying Golang's io.Reader and io.Writer Interfaces]]></title>
    <link href="http://nathanleclaire.com/blog/2014/07/19/demystifying-golangs-io-dot-reader-and-io-dot-writer-interfaces/"/>
    <updated>2014-07-19T19:35:00+00:00</updated>
    <id>http://nathanleclaire.com/blog/2014/07/19/demystifying-golangs-io-dot-reader-and-io-dot-writer-interfaces</id>
    <content type="html"><![CDATA[<p><img src="/images/iowriter/aviator.png"></p>

<p>If you&#8217;re coming to <a href="http://golang.org">Go</a> from a more flexible, dynamically typed language like Ruby or Python, there may be some confusion as you adjust to the Go way of doing things.  In my case, I had some trouble wrapping my head around <code>io.Reader</code>, <code>io.Writer</code>, <code>io.ReadCloser</code> etc.  What are they used for, and how can they be included in our Go programs for interesting and helpful results?</p>

<h1>Quick interface review</h1>

<p>To make up for some of the flexibility lost by not having generics, and for other reasons as well, Go provides an abstraction in the form of interfaces.</p>

<p>You can specify an interface and then any consumer of that interface will accept it.</p>

<pre><code class="go">type error interface {
    Error() string
}
</code></pre>

<p>Many standard library components of Go define interfaces.  In fact, the <code>error</code> type you know and love (hate?) is simply an interface which insists that a method named <code>Error</code> which consumes nothing and returns a string must be defined on a struct for the interface to count as satisfied.  Interfaces in Go are set <em>implicitly</em>, so all you have to do is define the required methods on your struct and it will qualify as implementing that interface.</p>

<p>For instance:</p>

<pre><code class="go">package main

import (
    "fmt"
    "os"
)

type Animal interface {
    Say() string
    Greet(Animal)
}

type Person struct {
}

func (p Person) Say() string {
    return "Hey there bubba!"
}

func (p Person) Greet(animalToGreet Animal) {
    fmt.Println("Hi!")
}

type Dog struct {
    age int
    breed string
    owner *Person
}

func (d Dog) Say() string {
    return "Woof woof!"
}

func (d Dog) Growl() {
    fmt.Println("Grrr!")
}

func (d *Dog) Snuggle() {
    // snuggle code...
}

func (d Dog) Sniff(animalToSniff Animal) (bool, error) {
    // sniff code...
    return true, nil
}

func (d Dog) Greet(animalToGreet Animal) {
    if _, ok := animalToGreet.(Person); ok {
        d.Snuggle()
    } else {
        friendly, err := d.Sniff(animalToGreet)
        if err != nil {
            fmt.Fprintln(os.Stderr, "Error sniffing a non-person")
        }
        if !friendly {
            d.Growl()
        }
    }
}

func main() {
    d1 := Dog{2, "shibe", &amp;Person{}}
    d2 := Dog{3, "poodle", &amp;Person{}}
    d2.Greet(d1)
    fmt.Println("Successfully greeted a dog.")
}
</code></pre>

<p>Run here: <a href="http://play.golang.org/p/m_RQeo9N1H">http://play.golang.org/p/m_RQeo9N1H</a></p>

<p>Yup, I &#8220;went there&#8221; with the Animal OO-ish (Go doesn&#8217;t have pure objects) cliché.</p>

<p>When you compile a program containing the above, the Go compiler knows that the <code>Dog</code> struct satisfies the <code>Animal</code> interface provided (it infers this because <code>Dog</code> implements the neccesary methods to qualify), so it won&#8217;t complain if you pass instances of of <code>Dog</code> to functions which demand an <code>Animal</code> type.  This allows for a lot of power and flexibility in your architecture and abstractions, without breaking the type system.</p>

<h1>So what&#8217;s with <code>io</code>?</h1>

<p><code>io</code> is a Golang standard library package that defines flexible interfaces for many operations and usecases around input and output.</p>

<p>See: <a href="http://golang.org/pkg/io/">http://golang.org/pkg/io/</a></p>

<p>You can use the same mechanisms to talk to files on disk, the network, STDIN/STDOUT, and so on.  This allows Go programmers to create re-usable &#8220;Lego brick&#8221; components that work together well without too much shimming or shuffling of components.  They smooth over cross-platform implemenation details, and it&#8217;s all just <code>[]byte</code> getting passed around, so everyone&#8217;s expectations (senders/writers and receivers/readers) are congruent.  You have <code>io.Reader</code>, <code>io.ReadCloser</code>, <code>io.Writer</code>, and so on to use.  Go also provides packages called <code>bufio</code> and <code>ioutil</code> that are packed with useful features related to using these interfaces.</p>

<h1>OK, but what can you do with it.</h1>

<p>Let&#8217;s look at an example to see how combining some of these primitives can be useful in practice.  I&#8217;ve been working on a project where I want to attach to multiple running Docker containers concurrently and stream (multiplex) their output to STDOUT with some metadata (container name) prepended to each log line.  Sounds easy, right? ;)</p>

<p>The Docker REST API bindings written by <a href="http://github.com/fsouza">fsouza</a> provide an abstraction whereby we can pass an <code>io.Writer</code> instance for STDOUT and STDERR of the container we are attaching to.  So we have control of a <code>io.Writer</code> that we inject in, but how do read what gets written by this container one line at a time, and multiplex/label the output together in the fashion I described in the previous paragraph?</p>

<p>We will use a combination of Go&#8217;s concurrency primitives, <code>io.Pipe</code>, and a <code>bufio.Scanner</code> to accomplish this.</p>

<p>Since the call to the API binding&#8217;s <code>AttachContainer</code> method hijacks the HTTP connection and consequently forces the calling goroutine to be blocked, we run each <code>Attach</code> call in its own goroutine.</p>

<p>We need an <code>io.Reader</code> to be able to read and parse the output from the container, but we only have the option to pass in an instance of <code>io.Writer</code> for STDOUT and STDERR.  What to do?  We can use a call to <code>io.Pipe</code> (see <a href="http://golang.org/pkg/io/#Pipe">here</a> for reference).  <code>io.Pipe</code> returns an instance of a <code>PipeReader</code>, and an instance of a <code>PipeWriter</code>, which are connected (calling the <code>Write</code> method on the <code>Writer</code> will lead directly to what comes out of <code>Read</code> in the <code>Reader</code>).  So, we can use the returned <code>Reader</code> to stream the output from the container.</p>

<p>The final step is to use a <code>bufio.Scanner</code> to read the output from the <code>PipeReader</code> line by line.  If you use the <code>Scan</code> method with a <code>range</code> statement, it will iterate line by line as we desire.  We have already generated the prefix earlier and saved it in the <code>Service</code> struct we are working with (<code>Service</code> in my implementation is a very light wrapper around a container).</p>

<p>Therefore, the final method looks like this:</p>

<pre><code class="go">func (s *Service) Attach() error {
    r, w := io.Pipe()
    options := apiClient.AttachToContainerOptions{
        Container:    s.Name,
        OutputStream: w,
        ErrorStream:  w,
        Stream:       true,
        Stdout:       true,
        Stderr:       true,
        Logs:         true,
    }
    fmt.Println("Attaching to container", s.Name)
    go s.api.AttachToContainer(options)
    go func(reader io.Reader, s Service) {
        scanner := bufio.NewScanner(reader)
        for scanner.Scan() {
            fmt.Printf("%s%s \n", s.LogPrefix, scanner.Text())
        }
        if err := scanner.Err(); err != nil {
            fmt.Fprintln(os.Stderr, "There was an error with the scanner in attached container", err)
        }
    }(r, *s)
    return nil
}
</code></pre>

<p>We kick off attaching to, and reading from, the container at the same time- when the attach is complete and starts streaming, the <code>scanner.Scan</code> loop will start logging.</p>

<h1>Conclude</h1>

<p>I had some trouble understanding <code>io.Writer</code>, <code>io.Reader</code>, etc. when getting started with Go (and recently as well), but I think I was over-thinking their simplicity and explicit power.  Additionally, learning about some higher-level abstractions related to them helped a lot.  Hopefully this article is useful for you and clears stuff up in the future.  I know that my Go has accelerated a lot since grokking these concepts, especially since so much (file IO etc.) relies on it.</p>

<p>Until next time, stay sassy Internet.</p>

<ul>
<li>Nathan</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Want to Work With Databases In Golang?  Let's Try Some gorp.]]></title>
    <link href="http://nathanleclaire.com/blog/2013/11/04/want-to-work-with-databases-in-golang-lets-try-some-gorp/"/>
    <updated>2013-11-04T18:58:00+00:00</updated>
    <id>http://nathanleclaire.com/blog/2013/11/04/want-to-work-with-databases-in-golang-lets-try-some-gorp</id>
    <content type="html"><![CDATA[<h1>Google&#8217;s Go</h1>

<p><a href="http://golang.org/">Go</a> is a new programming language released by <a href="http://www.google.com">Google</a>.  It has an excellent pedigree (see <a href="http://en.wikipedia.org/wiki/Rob_Pike">Rob Pike</a> and <a href="http://en.wikipedia.org/wiki/Ken_Thompson_%28computer_programmer%29">Ken Thompson</a>) and it brings a lot of interesting things to the table as a programming tool. Go has been the subject of rave reviews as well as controversy.  As Google is a web company it&#8217;s no surprise that Go seems hard-wired from the start to be used in the context of the modern web and the standard libaries include everything from <a href="http://golang.org/pkg/net/http/">HTTP servers</a> to <a href="http://golang.org/pkg/html/template/">a templating system</a> to address these ends.  A lot of companies and hobbyist hackers seem to enjoy Go as a utility language that replaces components which used to be written in Python or Perl (with Go offering better performance).</p>

<p>Its supporters emphasize its <a href="http://benchmarksgame.alioth.debian.org/u64q/benchmark.php?test=all&amp;lang=go&amp;lang2=yarv&amp;data=u64q">performance</a>, nifty approach to concurrency (it&#8217;s <a href="http://golang.org/doc/effective_go.html#concurrency">built right in</a>), and fast compile times as advantages.  Some of its detractors dislike its lack of exceptions and generics, but the purpose of this article is not to address these concerns, which have already been discussed <em>ad nauseum</em>.  Instead, this article will talk about and examine the <code>gorp</code> library.</p>

<p><img src="/images/gorp/gorp.jpeg" title="Eh?" ></p>

<p>I don&#8217;t actually mean GOOD OLD RAISINS &amp; PEANUTS, of course- I mean <a href="https://github.com/coopernurse/gorp">gorp</a>, an &#8220;ORM-ish library for Go&#8221;.  What is it, and how does it work its funny magic?</p>

<h1>ORM-ish?</h1>

<p>The README.md from <code>gorp</code>&#8217;s repository is just too great an introduction to not quote, check it out:</p>

<blockquote>
I hesitate to call gorp an ORM. Go doesn&#8217;t really have objects, at least not in the classic Smalltalk/Java sense. There goes the &#8220;O&#8221;. gorp doesn&#8217;t know anything about the relationships between your structs (at least not yet). So the &#8220;R&#8221; is questionable too (but I use it in the name because, well, it seemed more clever).

The &#8220;M&#8221; is alive and well. Given some Go structs and a database, gorp should remove a fair amount of boilerplate busy-work from your code.

I hope that gorp saves you time, minimizes the drudgery of getting data in and out of your database, and helps your code focus on algorithms, not infrastructure.
</blockquote>


<p>When I was looking into <a href="http://www.github.com/robfig/revel">Revel</a> as a possibility for a Go web application framework, I found myself frustrated by its lack of a database solution.  Persistence is just such a key aspect of web applications, and something that we&#8217;re so accustomed to letting frameworks take care of for us (a la Rails and Django) that it was hard to believe a large framework like Revel didn&#8217;t even want to touch the problem- especially since <a href="http://www.playframework.com/documentation/1.2.1/model">Play</a>, a large source of inspiration, provides such functionality.  Revel is awesome in a lot of other ways, like its code hotswap feature, but for now at least it is &#8220;bring-your-own-ORM&#8221; (or other database solution).</p>

<p>So I set off to look into this funny <code>gorp</code> business.  As it turns out, <code>gorp</code> is pretty straightforward and powerful.  At the time of writing, <code>gorp</code> can be used with MySQL, Sqlite3, and PostgreSQL (although there are some known issues that cause different drivers to behave slightly differently).</p>

<h1>Creating Tables</h1>

<p>The basic use case for <code>gorp</code> is to define some structs and then register them with an instance of <code>gorp</code>&#8217;s <code>DbMap</code> structure.  This structure is responsible for generating the raw SQL to perform basic database operations on a table that will mirror your custom defined structure.  <code>gorp</code> can easily create that table for you in the first place.  Check it out:</p>

<pre><code class="go">type Person struct {
    Id      int64    
    Created int64
    Updated int64
    FName   string
    LName   string
}

// connect to db using standard Go database/sql API
// use whatever database/sql driver you wish
db, err := sql.Open("mymysql", "tcp:localhost:3306*mydb/myuser/mypassword")

// construct a gorp DbMap
dbmap := &amp;gorp.DbMap{Db: db, Dialect: gorp.MySQLDialect{"InnoDB", "UTF8"}}

table := dbmap.AddTable(Person{}).SetKeys(true, "Id")
</code></pre>

<p>You can also use <code>AddTableWithName</code> if you don&#8217;t want the table name to be the same as the structure type&#8217;s name (in fact, <code>AddTable</code> calls <code>AddTableWithName</code>):</p>

<pre><code class="go">table := dbmap.AddTableWithName(Person{}, "People").SetKeys(true, "Id")
</code></pre>

<p>As you can imagine, being able to easily create and drop tables like this is useful for unit tests.</p>

<p>You can use structure field tags if you want to change the name of the columns in the actual SQL (let&#8217;s say your team has a convention to have only lowercase column names, but all members of a Go struct must be uppercase).  Additionally you can tell <code>gorp</code> to ignore fields completely with <code>db:"-"</code>:</p>

<pre><code class="go">type Person struct {
    Id       int64                        `id`
    Created  int64                        `created`
    Updated  int64                        `modified`
    FName    string                       `firstName`
    LName    string                       `lastName`
    Comments *SomeNonPersistentStructure  `db:"-"`
}
</code></pre>

<p>A seemingly undocumented feature is that you can set the size of the table columns manually.  If you don&#8217;t, <code>gorp</code> will automatically figure something out for you that may be a bit too large or too small.  For example, <code>gorp</code> turns this structure definition:</p>

<pre><code>// A Thing is a post (link submission or a comment)
type Thing struct {
    Id            int64
    Username      string
    Href          string
    Upvotes       int64
    Downvotes     int64
    Description   string
    ParentThingId int64
    Created       int64
    Updated       int64
}
</code></pre>

<p>into this (with default behavior / MySQL driver):</p>

<pre><code>+---------------+--------------+------+-----+---------+-------+
| Field         | Type         | Null | Key | Default | Extra |
+---------------+--------------+------+-----+---------+-------+
| Id            | bigint(20)   | YES  |     | NULL    |       |
| Username      | varchar(255) | YES  |     | NULL    |       |
| Href          | varchar(255) | YES  |     | NULL    |       |
| Upvotes       | bigint(20)   | YES  |     | NULL    |       |
| Downvotes     | bigint(20)   | YES  |     | NULL    |       |
| Description   | varchar(255) | YES  |     | NULL    |       |
| ParentThingId | bigint(20)   | NO   | PRI | NULL    |       |
| Created       | bigint(20)   | YES  |     | NULL    |       |
| Updated       | bigint(20)   | YES  |     | NULL    |       |
+---------------+--------------+------+-----+---------+-------+
</code></pre>

<p>When you call <code>gorp.DbMap.AddTableWithName</code>, it returns you a pointer to a <code>TableMap</code> struct that you can use to set the size of the columns.  So you think 255 characters is a bit long for a username?</p>

<pre><code>t1 := dbmap.AddTable(Person{}).SetKeys(true, "Id")
t1.ColMap("Username").SetMaxSize(25)
</code></pre>

<p>The things you learn from reading the unit tests (and digging in the <a href="https://github.com/robfig/revel/blob/master/samples/booking/app/controllers/gorp.go">Revel examples</a>), huh?</p>

<h1>CRUD</h1>

<p>Let&#8217;s take a look at what CRUD (Create-Read-Update-Delete) looks like using <code>gorp</code>-mapped structures.</p>

<p>Inserting a new row is simple (note that you have to declare the structs as pointers so that optional callback hooks can operate on your actual data instead of copies):</p>

<pre><code class="go">person := &amp;Person{
    Created: time.Now().UnixNow(), 
    Updated: time.Now().UnixNow(),
    FName: "Joe",
    LName: "Smith"
}
err := dbmap.Insert(person)
</code></pre>

<p>Want to select by primary key?</p>

<pre><code class="go">primaryKey := 1
p1, err := dbmap.Get(Person{}, primaryKey)
</code></pre>

<p>How about selecting by arbitrary (non-primary-key) fields?  You can use <code>dbm.Select</code> to get a slice, or <code>dbm.SelectOne</code> to populate the slice or structure with the revelant data.</p>

<pre><code class="go">var ids []int64
_, err := dbmap.Select(&amp;ids, "select id from Person")

lname = "LeClaire"
var person Person
err := dbmap.SelectOne(&amp;person, "select * from Person where LName=?", lname)
</code></pre>

<p>Update and delete work similarly :</p>

<pre><code class="go">// count is the # of rows updated / deleted
person.FName = "Nate" 
count, err := dbmap.Update(person)

// or just delete it 
count, err := dbmap.Delete(person)
</code></pre>

<h1>How does it do all of this crazy voodoo?</h1>

<p>Obviously gorp is really cool, and useful.  So how does it work?</p>

<p><img src="/images/gorp/use-the-source-luke.jpeg" title="Best way to learn." ></p>

<p>I had no idea, but I remembered the words of Jeff Atwood and other wise folks and cracked open the <a href="https://github.com/coopernurse/gorp/blob/master/gorp.go">source code on github</a>.  Reading the unit tests also proved useful in understanding how <code>gorp</code> should be used (one of the virtues of meticulously tested code - it documents).</p>

<p>Immediately upon cracking open the definition of <code>DbMap.AddTable</code> and <code>DbMap.AddTableWithName</code>, I had one of those &#8220;aha&#8221; moments that programmers know so well.</p>

<pre><code class="go">// AddTableWithName has the same behavior as AddTable, but sets
// table.TableName to name.
func (m *DbMap) AddTableWithName(i interface{}, name string) *TableMap {
        t := reflect.TypeOf(i)
        if name == "" {
                name = t.Name()
        }

        // check if we have a table for this type already
        // if so, update the name and return the existing pointer
        for i := range m.tables {
                table := m.tables[i]
                if table.gotype == t {
                        table.TableName = name
                        return table
                }
        }

        tmap := &amp;TableMap{gotype: t, TableName: name, dbmap: m}
        tmap.columns, tmap.version = readStructColumns(t)
        m.tables = append(m.tables, tmap)

        return tmap
}
</code></pre>

<p>Of course, it uses reflection!  Go&#8217;s <a href="http://golang.org/pkg/reflect/">reflect</a> package is what powers this manipulation and mapping of structure metadata (I wasn&#8217;t aware Go was capable of reflection when I started using <code>gorp</code>, so it was a bit of a surprise to find this out).</p>

<p>Suddenly everything became clearer to me and I feel like the code for <code>AddTableWithName</code> is fairly self-explanatory if you are familiar with the usage of the library.  The first part of the method deals with naming the table (user defined or based on the name of the structure).  The middle section checks to see if the table already is in existence and if so it updates the name (consequently, we can set up a table for a structure with one name, then change the table name later on if we want).  Lastly, it adds the table if it doesn&#8217;t exist and returns a pointer to the <code>TableMap</code> structure (we discussed this structure briefly earlier).</p>

<p>The code for the <code>readStructColumns</code> internal method that you see called near the end of the method is pretty cool as well, it powers <code>gorp</code>&#8217;s ability to deal with struct embedding (a pretty cool feature of the libary IMO).  I won&#8217;t reproduce it here, but if you are curious <a href="https://github.com/coopernurse/gorp/blob/master/gorp.go">go check it out</a>!</p>

<h1>The future</h1>

<p>Alas, we developers are never easy to please forever.  Here I will note some things that may become issues for users of <code>gorp</code>, and hopefully get the ball rolling on conversation about directions for <code>gorp</code>&#8217;s future development.</p>

<p>Support for <code>TEXT</code> columns (and maybe other, &#8220;weirder&#8221; column types like PostgreSQL&#8217;s <a href="http://www.postgresql.org/docs/9.2/static/datatype-json.html">json data type</a>) seems like something that will be needed to really bring <code>gorp</code> into the limelight as a robust and mature tool (see <a href="https://github.com/coopernurse/gorp/issues/34">this issue</a> on github, where someone brings up <code>TEXT</code> specifically).  A <code>VARCHAR</code> column arguably would be inappropriate for storing the content of a Reddit comment or a blog post, for example.  I&#8217;d be curious how the maintainers are interested in handling this- getting into defining custom data types with <code>gorp</code> (e.g. <code>gorp.Text</code>) might be dicey, for instance, or it could prove to be a robust solution.  In the long run, it&#8217;s worth considering how much of <code>gorp</code>&#8217;s flexibility and power comes from its ability to discern those kinds of things with minimal input from the user, and how much of that we&#8217;re willing to give up to have a VERY robust database / ORM-ish solution for Golang.</p>

<p>Other tough nuts to crack with <code>gorp</code> (Golang&#8217;s strict/static typing, which is definitely one of its advantages in some ways, is partially what makes some of these so challenging) :</p>

<ul>
<li>Handling relational data</li>
<li>Joins (the existing solution looks pretty workable, but feels a bit stiff - admittedly I haven&#8217;t tried it though)</li>
<li>Data migrations</li>
</ul>


<p>Any ideas?</p>

<p>Also, not to be &#8220;that guy&#8221;, but it could probably stand to be broken up into a few different files (one for each of the different structures, for instance) instead of one large <code>gorp.go</code> file.</p>

<h1>Conclusion</h1>

<p><code>gorp</code> is a very cool, if still young, tool / library.  I find it to be a good combination of abstraction and practicality.  What do you think?</p>

<p>Thanks for reading, I&#8217;ll see you next week.</p>

<p>Nate</p>
]]></content>
  </entry>
  
</feed>
