<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: unit testing | nathan leclaire]]></title>
  <link href="http://nathanleclaire.com/blog/categories/unit-testing/atom.xml" rel="self"/>
  <link href="http://nathanleclaire.com/"/>
  <updated>2014-09-29T03:20:27+00:00</updated>
  <id>http://nathanleclaire.com/</id>
  <author>
    <name><![CDATA[Nathan LeClaire]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Unit Testing Services in AngularJS for Fun and for Profit]]></title>
    <link href="http://nathanleclaire.com/blog/2014/04/12/unit-testing-services-in-angularjs-for-fun-and-for-profit/"/>
    <updated>2014-04-12T23:14:00+00:00</updated>
    <id>http://nathanleclaire.com/blog/2014/04/12/unit-testing-services-in-angularjs-for-fun-and-for-profit</id>
    <content type="html"><![CDATA[<p><img src="/images/unit-test-angularjs-service/jasmine.png" title="Your new best friend." ></p>

<p>If there was a way to reduce the number of defects in the code you write (or manage), improve the quality and time to market of deliverables, and make things easier to maintain for those who come after you- would you do it?</p>

<p>Right about now, especially given the content of the article, you might be sensing that I&#8217;m about to jump into the usual testing zealot rant.  And you&#8217;re right.</p>

<p>How many times have you heard some variant on, &#8220;Writing tests isn&#8217;t as important as delivering finished code?&#8221;  If you&#8217;re like me, it&#8217;s way too many, and god help you if you&#8217;re working with no tests at all.  Programmers are human and we all make mistakes.  So test your code.  The number of times testing my code has helped me catch unforeseen issues before they became flat-out bugs, prevent future regressions, or simply architect better is pretty amazing.  And this is coming from a guy who used to hate writing tests for code.  <em>Hated</em> it.</p>

<p>I think that stemmed more from a lack of understanding how to do it than anything else.  When systems get complex and have a lot of moving parts is when it is most critical to test them, and that is also when it becomes the most difficult to test them.  Without an understanding of your tools (e.g. mocks) or why each piece is important, and especially with a lack of easily accessible examples, testing code can be really intimidating and frustrating.</p>

<p>So what do you do?  You commit code without tests.  You are cowboy.  Cowboy no test.</p>

<p><img src="/images/unit-test-angularjs-service/cowboy.png"></p>

<p>But as some of you probably know all too well, this is dangerous.  It&#8217;s like going on vacation in the Caribbean using your credit card.  Fun for a while, and everything seems great, until suddenly reality hits and <a href="http://en.wikipedia.org/wiki/Red_Queen's_race">it takes all the running you can do just to stay in the same place</a>.</p>

<p>Fortunately Angular treats us really well as far as testing goes.  It just requires some additional explanation, since the quality of resources available for both Angular <em>and</em> Jasmine is really not fantastic.  It&#8217;s better than a year ago, definitely, but not fantastic.</p>

<p>So here I am doing a brain dump of sorts of what I know about testing services, which are part of the <a href="http://nathanleclaire.com/blog/2014/03/15/angularjs-isnt-mvc-its-sdc/">lifeblood</a> of any Angular application.</p>

<h1>Section 1: In Which I Proclaim &#8220;I love Dependency Injection!&#8221;</h1>

<p>When I first saw someone present on Angular, they got kind of hand-wavey about <a href="http://en.wikipedia.org/wiki/Dependency_injection">Dependency Injection</a>.  &#8220;The way I see it, it&#8217;s basically magic and I don&#8217;t have to think about it.&#8221;  Ahhh.  Not what I like to hear.</p>

<p>I get that it can be kind of scary, hearing people throw around jargon like injectors and providers and dependency injection like they&#8217;re nothing, but you can get it.  I know you can.</p>

<p>It&#8217;s simple.  Not easy, but simple.  When Angular runs the code that you define for a controller or a service, it looks at the parameters you have attached to the function and sets them correctly for that run based on their names.  Let&#8217;s say that you have something like this:</p>

<pre><code class="js">angular.module("foo").controller("NavCtrl", function ($scope, tabService) {
  // ...
});
</code></pre>

<p>The order of the parameters on your function doesn&#8217;t matter.  You could just as easily have said <code>function (tabService, $scope)</code> and both of those values would still be set correctly.  That&#8217;s a nice advantage in itself, and it&#8217;s why you see funny business like:</p>

<pre><code class="js">angular.module("foo").controller("NavCtrl", [
  "$scope",
  "tabService",
  function($scope, tabService) {
    // ...
  }
]);
</code></pre>

<p>That&#8217;s so that <a href="http://en.wikipedia.org/wiki/Minification_%28programming%29">minification</a>, which renames all of your passed variables in functions, doesn&#8217;t blow up Angular&#8217;s dependency injection.  Angular knows how to handle this if you use the second form of notation.</p>

<p>But why are we even messing with this at all?  It&#8217;s because if we inject the dependencies, we can control them from the outside world.  And this is eminently important for testing.</p>

<p>This kind of thing (admittedly contrived for effect):</p>

<pre><code class="js">function mungeSomeData(data) {
  var dataGetter, dataParser, dataTransformer;
  dataGetter = new DataGetter();
  dataParser = new DataParser();
  dataTransformer = data.isXML() ? new XMLDataTransformer() : new JSONDataTransformer();
  // ...
}
</code></pre>

<p>Doesn&#8217;t use Depdency Injection, and is a nightmare to test.  Minimizing surface area to test is so so important, and by writing code that way you make your surface area HUGE and slippery.</p>

<p>Side note:  It is Angular convention to have a dollar sign (<code>$</code>) in the front of the names of things that are both injected (<code>$scope</code>, <code>$timeout</code>, <code>$http</code>) and built-in to Angular.  If you see <code>$scope</code> being used in the link function of a directive, that is both wrong and confusing since parameters are <em>passed</em> to the link function of directives, not injected.  Please Hulk out when you see this and correct the code.  If you are using <code>vim</code> a simple <code>:%s/$scope/scope/</code> (or perhaps just <code>:s</code> in visual mode if you have instances of <code>$scope</code> that <em>shouldn&#8217;t</em> be replaced) will do the trick.</p>

<p><strong>Q: So what does that have to do with unit testing AngularJS services, Nate?</strong></p>

<p>It has everything to do with testing services since they are injected.  So, in unit testing a service, you can control precisely what goes on in one in addition to all of its dependencies.</p>

<p><strong>Q: Will you show us some actual Jasmine code already?</strong></p>

<p>Getting there.</p>

<h1>Section 2: In Which I Write an Actual Service, and a Unit Test for It</h1>

<p>Let&#8217;s say that I&#8217;m writing an Angular app which interacts with the Reddit API.  Since we know that services are the part which Angular uses to interact with the outside world, we will write a service to handle our needs.</p>

<p>We are going to write one with a method <code>getSubredditsSubmittedToBy(user)</code> which returns a list of which subreddits a user has submitted to recently.  We can use <a href="https://egghead.io/lessons/angularjs-chained-promises">promise chaining</a> to achieve this (aggregating the big glob of JSON returned by the API call) so that our controller stays super lean.</p>

<h2>Writing the Service</h2>

<p>Usage (inside controller):</p>

<pre><code>userService.getSubredditsSubmittedToBy("yoitsnate").then(function(subreddits) {
  $scope.subreddits = subreddits;
});
</code></pre>

<p>So nice and readable!</p>

<p>Our service looks like this:</p>

<pre><code class="js">angular.module("reddit").service("userService",
function($http) {
  return {
    getSubredditsSubmittedToBy: function(user) {
      return $http.get("http://api.reddit.com/user/" + user + "/submitted.json").then(function(response) {
        var posts, subreddits;

        posts = response.data.data.children;

        // transform data to be only subreddit strings
        subreddits = posts.map(function(post) {
          return post.data.subreddit;
        });

        // de-dupe
        subreddits = subreddits.filter(function(element, position) {
          return subreddits.indexOf(element) === position;
        });

        return subreddits;
      });
    }
  };
});
</code></pre>

<h2>Writing the test</h2>

<p>We will write a test using <a href="http://pivotal.github.io/jasmine/">Jasmine</a>.  Jasmine is a Behavior-Driven-Development framework, which is sort of a roundabout way of saying that our tests include descriptions of the sections that they are testing and what they are supposed to do.  This is done using nested <code>describe</code> and <code>it</code> blocks, which look really weird at first (something about a function as short as <code>it</code> is just unsettling to me ;) ) but can be helpful in understanding what the test is intended to, well, test.</p>

<p>This is quite helpful as sometimes large elaborate codebases have large elaborate tests and it can be hard to figure out what&#8217;s what.  For instance, in PHPUnit, this kind of &#8220;built-in documentation&#8221; is spread out and mostly optional, and makes complex unit tests a bit trickier to read.</p>

<p>Using Karma we first tell it what module we&#8217;re working in (<code>"reddit"</code>), run an inject function to set up our dependencies and get the service under test (this allows us access to Angular&#8217;s injector so we can set local test variables), then run an actual test in the <code>it</code> block.</p>

<p>Notice that in the <code>inject</code> method we inject in <code>_foo_</code>, with an underscore on either side of the name of the actual service, so that we can set it in the outer <code>describe</code> closure.  This is by design, as the Angular maintainers foresaw (or discovered) that:</p>

<pre><code>var redditService;
beforeEach(inject(redditService) {
  redditService = redditService;
});
</code></pre>

<p>would result in an error.</p>

<p>So use <code>_underscoreNotation_</code> to get the service that you want to test :)</p>

<pre><code>"use strict";

describe("reddit api service", function () {
  var redditService, httpBackend;

  beforeEach(module("reddit"));

  beforeEach(inject(function (_redditService_, $httpBackend) {
    redditService = _redditService_;
    httpBackend = $httpBackend;
  }));

  it("should do something", function () {
    httpBackend.whenGET("http://api.reddit.com/user/yoitsnate/submitted.json").respond({
        data: {
          children: [
            {
              data: {
                subreddit: "golang"
              }
            },
            {
              data: {
                subreddit: "javascript"
              }
            },
            {
              data: {
                subreddit: "golang"
              }
            },
            {
              data: {
                subreddit: "javascript"
              }
            }
          ]
        }
    });
    redditService.getSubredditsSubmittedToBy("yoitsnate").then(function(subreddits) {
      expect(subreddits).toEqual(["golang", "javascript"]);
    });
    httpBackend.flush();
  });

});
</code></pre>

<p>Our mock data here mimics the actual data returned by the Reddit API, but only enough that we get the necessary bits of structure in place and can account for, say, the duplicate case.  If we wanted to add different functionality for different pieces of the API, or of this call, we could just define new <code>httpBackend</code> responses in new <code>it</code> blocks and test things the same way without having to worry about the bits of the API response we don&#8217;t need.</p>

<h2>The provider idiom</h2>

<p>Unfortunately my simple example above breaks down a little bit if we have additional dependencies on other services in our service under test.  What do we do in this case?  We need to control these injected parameters, and to do so we use <code>$provide</code>.  <code>$provide</code> can take the name of e.g. a service and dictate what to provide for it.  In doing so we can, say, use a spy object instead of the &#8220;real deal&#8221;.</p>

<pre><code>beforeEach(module(function($provide) {
  $provide.value("myDependentService", serviceThatsActuallyASpyObject);
}));
</code></pre>

<p>Note that <code>$provide</code> should always be called before your call to <code>$inject</code>, since the former dicates what the latter should use.</p>

<h1>Section 3: Helpful Tips</h1>

<h2>Stutter.</h2>

<p>If you change a <code>describe</code> or <code>it</code> block to <code>ddescribe</code> or <code>iit</code> respectively <a href="http://karma-runner.github.io/0.12/index.html">Karma</a> (<a href="http://nathanleclaire.com/blog/2013/12/13/how-to-unit-test-controllers-in-angularjs-without-setting-your-hair-on-fire/">Angular&#8217;s test runner</a>) will run only that block.  This is called <a href="https://github.com/davemo/jasmine-only">stuttering</a> and it is very useful if you don&#8217;t want to run your entire test suite every time, as the larger the codebase gets the longer this will take to do.</p>

<h2>Don&#8217;t be afraid to rearrange code that is hard to test</h2>

<p>If you can move code around to make it easier to test without changing other things, DO IT (in a general sense I find that this eases readability and maintainability too).  For instance I found that in one instance in a service a colleague was relying on a function call that was both unneccesary and confusing, and ultimately broke the chain of promises.  So I deleted the function definition and inlined the code it contained.  The resulting code was a bit easier to read and test.</p>

<h2>Cheat.</h2>

<p>You can create stubbed objects quite easily in JavaScript, so if there&#8217;s no need to introduce the extra complexity of a spy (see next section), then do so.  For example, if you can just return <code>4</code> from a method every time you call it instead of counting the elements or whatever it usually does, then do so.</p>

<h2>Do you need a Spy?</h2>

<p>If you need more power / assertions out of the last point, Jasmine provides Spies for you to use.</p>

<p>They&#8217;re a little out of scope for this article, but they should provide you all of the flexibility you need for faking data / objects / calls and testing what was faked.</p>

<p>For a good reference, see this <a href="http://tobyho.com/2011/12/15/jasmine-spy-cheatsheet/">Jasmine spy cheatsheet</a>.</p>

<h2>Or just use <code>$q</code> / manually manage promises</h2>

<p>I found myself in kind of a funny situation at work recently.  We use Angular for structure but the codebase we are working on has a lot of pre-existing bits/modules that were not really moved over to Angular fully due to intense deadline pressure.  So, we find ourselves making XMLHttpRequests outside of <code>$http</code> land, but the original programmers still return promises from their outside world modules for us to use (it&#8217;s kind of an odd setup that we don&#8217;t really have time to refactor).  So, I just caused the functions that take care of those API calls return promises that I control using <code>$q</code>.</p>

<pre><code class="js">var mockPromise;
mockDeferred = $q.defer();
someSpyObj.methodThatReturnsAPromise.andCallFake(function () {
  return mockDeferred.promise;
});
mockDeferred.resolve({
  things: "foo",
  otherThings: "bar"
});
</code></pre>

<h1>Conclusion.</h1>

<p>Jasmine tests are pretty quick to write once you get the hang of them.  Seriously guys, there&#8217;s no excuse.</p>

<p>The <a href="http://blog.codinghorror.com/coding-for-violent-psychopaths/">violent psychopath who ends up maintaining your code</a> will thank you.  Or at least not murder you.</p>

<p>Until next time, stay sassy Internet, and <a href="http://nathanleclaire.com">consider subscribing to my blog</a>.</p>

<ul>
<li>Nathan</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Speed Up Your Workflow By Running PHPUnit Tests Inside of Vim]]></title>
    <link href="http://nathanleclaire.com/blog/2014/01/20/speed-up-your-workflow-by-running-phpunit-tests-inside-of-vim/"/>
    <updated>2014-01-20T23:30:00+00:00</updated>
    <id>http://nathanleclaire.com/blog/2014/01/20/speed-up-your-workflow-by-running-phpunit-tests-inside-of-vim</id>
    <content type="html"><![CDATA[<p><img src="/images/vim-phpunit/phpunitdemo.gif" title="No more CTRL Z for me." ></p>

<p>If you&#8217;re a dev that cares about nice, clean, working code you should probably be writing unit tests.  I&#8217;ve discussed unit testing in <a href="http://angularjs.org">AngularJS</a> a bit in <a href="http://nathanleclaire.com/blog/2013/12/13/how-to-unit-test-controllers-in-angularjs-without-setting-your-hair-on-fire/">one of my previous posts</a>, but what if you are working on the server side with one of the <a href="http://langpop.com/">most wildly popular web application languages of all time</a>?  That&#8217;s right folks, I&#8217;m talking about <a href="http://php.net/">PHP</a> and whether you love it or hate it if you are working with it there&#8217;s a damn good chance that you are unit testing it with the venerable <a href="http://phpunit.de/">PHPUnit</a> (if you&#8217;re not unit testing at all, you&#8217;re on the naughty list).  At the time of writing, this is what I do at my day job (my night job is as a costumed crusader fighting crime in the mean streets of <a href="http://www.a2gov.org/Pages/default.aspx">Ann Arbor, Michigan</a>.  For a long time the unit testing part of my development workflow in PHP went something like this:</p>

<ol>
<li>Be editing a PHP file and the file that tests it inside of <code>vim</code> over <code>ssh</code></li>
<li>Change something in the test or the class that is likely to break the test, or add new tests</li>
<li>Pop out of <code>vim</code> using <code>CTRL+Z</code> to suspend the process, and run the test on the command line using <code>phpunit --colors FileTest.php</code></li>
<li>Note the results of the test.</li>
<li>Type <code>fg</code> to get back into <code>vim</code></li>
<li>Change the files to correspond <em>OR</em> Wait, what was the thing that was off again?</li>
<li><code>GOTO 1</code></li>
</ol>


<p>Needless to say it&#8217;s a little exhausting, especially on those days where your brain&#8217;s moving slower than your fingers and you just can&#8217;t seem to inject enough coffee into your system.  But if your workflow is like this, you might be excited to find out that there is a better way.</p>

<h1>Let&#8217;s Write Some VimScript</h1>

<blockquote><p>And when you gaze long into an abyss the abyss also gazes into you.</p>

<ul>
<li><a href="http://en.wikiquote.org/wiki/Friedrich_Nietzsche">Friedrich Nietzsche</a></li>
</ul>
</blockquote>

<p>If you&#8217;re a <code>vim</code> poweruser, or even just a regular user, your first impulse towards solving this problem might be to execute commands using <code>:!phpunit @%</code>.  In case you&#8217;re not familiar with this syntax, you just learned that you can preface commands with <code>!</code> (bang) to run them in the shell and that <code>@%</code> refers to the file opened in the current buffer.  This could work pretty well (and does) in a lot of cases, however it has a few disadvantages:</p>

<ul>
<li>You have to type out the whole sequence every time, which is really annoying even if you are a fast typer and it adds a second or two onto your &#8220;writecode-runtest-repeat&#8221; cycle each time that really begins to add up quickly</li>
<li>You can&#8217;t see the results inside a <code>vim</code> buffer and manipulate them side-by-side with the test and code under test.  You could theoretically use <code>screen</code> for this, but I&#8217;ve always run into issues getting <code>screen</code> to work perfectly with my <code>vim</code> setup</li>
<li>In my use case (not sure if this is universal), PHPUnit is finnicky about <em>where</em> you run the tests from, and for a variety of reasons I don&#8217;t like to <code>:cd</code> away from the home directory of the project I&#8217;m working on very often (not to mention that&#8217;s an extra step in the cycle).  <code>:set autochdir</code> would fix this, but for large projects I&#8217;m not often a fan of <code>autochdir</code>.</li>
</ul>


<p>You could also try to look for a plugin, but who wants yet <em>another</em> <code>vim</code> plugin / coloring theme / whatever to juggle?</p>

<p>So what&#8217;s a unit testing junkie to do?  We have to dig into VimScript to automate this.  Hoo boy.  But have no fear, thanks to <a href="http://stevelosh.com/">Steve Losh</a>&#8217;s <a href="http://learnvimscriptthehardway.stevelosh.com/">Learn VimScript the Hard Way</a> I&#8217;ve figured out a great solution for you.</p>

<p>Put this code inside of your <code>.vimrc</code> file:</p>

<pre><code>function! RunPHPUnitTest()
    cd %:p:h
    let result = system("phpunit " . bufname("%"))
    split __PHPUnit_Result__
    normal! ggdG
    setlocal buftype=nofile
    call append(0, split(result, '\v\n'))
    cd -
endfunction

nnoremap &lt;leader&gt;u :call RunPHPUnitTest()&lt;cr&gt;
</code></pre>

<p>This will remap the keyboard shortcut <code>&lt;leader&gt;u</code> (run in normal mode) to run <code>phpunit</code> on the file you&#8217;re currently editing (hopefully a test, or else there will be no result) in the directory where it is based, and spit out the results into a new window.  In case you&#8217;re unfamiliar, the <code>&lt;leader&gt;</code> key in <code>vim</code> is <code>'\'</code> by default, but frequently it gets remapped to other keys (mine is mapped to <code>','</code>).</p>

<p>I really like this shortcut since it allows me to look at the test results side by side with the files I&#8217;m working on.  This code generates a new test result window each time you run it, so you have to <code>:q</code> out of old ones manually.  This has never bothered me <em>too</em> much, but if you know of a way to change it so that it kills old windows automatically I&#8217;d love to hear from you.</p>

<p>If you have a file with a lot of test methods in it, <code>vim</code> will be somewhat awkardly locked up for a minute waiting for the results, which it will spit out all at once when it is finished instead of in real-time like when you run <code>phpunit</code> on the command line, but at this time <code>vim</code> does not support streaming input buffers as far as I am aware.  So it&#8217;s something that has to be lived with if you want to use the functionality this way.  If you know of a workaround for this, you should <a href="mailto:nathanleclaire@gmail.com">let me know</a>.  Or, you can use the next tip to execute just a few tests at a time.</p>

<h1>But Can We Do Better?</h1>

<p>Sure, we can always do better.  I really like using phpunit with the <code>--filter</code> option, since it allows you to focus on only running the tests you are interested in, instead of the whole kit and kaboodle.  This speeds things up really significantly.  How can we include this in our little VimScript function?</p>

<p>We&#8217;ll pass a parameter to our <code>RunPHPUnitTest()</code> function to indicate whether we want to do a <code>--filter</code> run or not, and if so we will yank the current word to use as the argument for the <code>--filter</code> parameter.  So, in our use case, if our vim cursor is hovering over the name of the function we want to run in the test file (as in <code>function testWhatever()</code>), and we press <code>&lt;leader&gt;f</code>, it will run PHPUnit just for that test.  Revised, the code in our <code>.vimrc</code> file looks like this:</p>

<pre><code>function! RunPHPUnitTest(filter)
    cd %:p:h
    if a:filter
        normal! T yw
        let result = system("phpunit --filter " . @" . " " . bufname("%"))
    else
        let result = system("phpunit " . bufname("%"))
    endif
    split __PHPUnit_Result__
    normal! ggdG
    setlocal buftype=nofile
    call append(0, split(result, '\v\n'))
    cd -
endfunction

nnoremap &lt;leader&gt;u :call RunPHPUnitTest(0)&lt;cr&gt;
nnoremap &lt;leader&gt;f :call RunPHPUnitTest(1)&lt;cr&gt;
</code></pre>

<p>In action:</p>

<p><img src="/images/vim-phpunit/phpunitdemofilter.gif" title="So much faster, especially in big files." ></p>

<h1>Conclusion</h1>

<p>I&#8217;d rather script my editor in Python.  JUST KIDDING.  Kind of.</p>

<p>Until next week, stay sassy Internet.  And keep that code coverage strong.</p>

<p>Cheers,</p>

<ul>
<li>Nathan</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Unit Test Controllers In AngularJS Without Setting Your Hair On Fire]]></title>
    <link href="http://nathanleclaire.com/blog/2013/12/13/how-to-unit-test-controllers-in-angularjs-without-setting-your-hair-on-fire/"/>
    <updated>2013-12-13T23:03:00+00:00</updated>
    <id>http://nathanleclaire.com/blog/2013/12/13/how-to-unit-test-controllers-in-angularjs-without-setting-your-hair-on-fire</id>
    <content type="html"><![CDATA[<p>Developers almost universally agree that unit tests are a <em>VERY GOOD THING</em> when working on a project.  They help you feel like your code is airtight, ensure reliability in production, and let you refactor with confidence when there is a need to do so.</p>

<p><img src="/images/angularjs-unit-testing/test-code-refactor-cycle.png" title="The Test-Driven Development cycle." ></p>

<p>AngularJS code touts its high degree of <a href="http://angularjs.org/#embed-and-inject">testability</a>, which is a reasonable claim.  In much of the documentation end to end tests are provided with the examples.  Like so many things with Angular, however, I was finding that although unit testing was simple, it was not easy.  Examples were sparse and though the <a href="http://docs.angularjs.org/guide/dev_guide.unit-testing">official documentation</a> provided some snippets of examples, putting it all together in my &#8220;real-world&#8221; case was proving challenging.  So here I&#8217;ve written a little bit about how I ended up getting that wonderful green light for a passing build to show up.</p>

<h1>Instant Karma</h1>

<p><a href="http://karma-runner.github.io/">Karma</a> is a test runner for JavaScript that was created by the Angular team.  It is a very useful tool as it allows you to automate tasks that you would otherwise have to do by hand or with your own cobbled-together collection of scripts (such as re-running your test suite or loading up the dependencies for said tests).  Karma and Angular go together like peanut butter and jelly.</p>

<p>With Karma, you simply define a configuration file, start Karma, and then it will take care of the rest, executing the tests in the browser(s) of your choice to ensure that they work in the environments where you plan on deploying to.  You can specify these browsers in the aforementioned configuration file.  <a href="https://github.com/angular/angular-seed">angular-seed</a>, which I highly recommend, comes with a decent out-of-the-box Karma config that will allow you to hit the ground running quickly.   The Karma configuration in my most recent project looks like this:</p>

<pre><code>module.exports = function(config) {
    config.set({
        basePath: '../',

        files: [
            'app/lib/angular/angular.js',
            'app/lib/angular/angular-*.js',
            'app/js/**/*.js',
            'test/lib/recaptcha/recaptcha_ajax.js',
            'test/lib/angular/angular-mocks.js',
            'test/unit/**/*.js'
        ],

        exclude: [
            'app/lib/angular/angular-loader.js',
            'app/lib/angular/*.min.js',
            'app/lib/angular/angular-scenario.js'
        ],

        autoWatch: true,

        frameworks: ['jasmine'],

        browsers: ['PhantomJS'],

        plugins: [
            'karma-junit-reporter',
            'karma-chrome-launcher',
            'karma-firefox-launcher',
            'karma-jasmine',
            'karma-phantomjs-launcher'
        ],

        junitReporter: {
            outputFile: 'test_out/unit.xml',
            suite: 'unit'
        }

    })
}
</code></pre>

<p>Which is very similar to the default configuration in <a href="https://github.com/angular/angular-seed">angular-seed</a>, except for a few things:</p>

<ul>
<li>I have switched the browser the tests run in from Chrome to <a href="http://phantomjs.org/">PhantomJS</a>, a headless browser, so that they can run without opening a browser window and causing an awkward viewport shuffle in OSX.  Therefore the <code>plugins</code> and <code>browsers</code> settings have been changed.</li>
<li>I added <code>recaptcha_ajax.js</code>, the minified file that Google provides for their Recaptcha service, since my app depends on it being included.  Having this change be as simple as adding a line in the Karma config file was really nice.</li>
</ul>


<p><code>autoWatch</code> is a particularly cool setting, since it will have Karma re-run your tests whenever they, or the files they test, change.</p>

<p>You can install Karma with:</p>

<pre><code>npm install -g karma
</code></pre>

<p><a href="https://github.com/angular/angular-seed">angular-seed</a> provides a handy little script for starting the Karma test runner, which is in <code>scripts/test.sh</code>.  Use it!</p>

<h1>Writing Tests With Jasmine</h1>

<p>Most of the resources available at the time of writing for unit testing with Angular use <a href="http://pivotal.github.io/jasmine/">Jasmine</a>, a behavior-driven development framework for testing JavaScript code.  That&#8217;s what I&#8217;ll be describing here.</p>

<p>To unit test an AngularJS controller, you can take advantage of Angular&#8217;s <a href="http://docs.angularjs.org/guide/di">dependency injection</a> and inject your own version of the services those controllers depend on to control the environment in which the test takes place and also to check that the expected results are occurring.  For example, I have this controller defined in my app to control the highlighting of which tab has been navigated to:</p>

<pre><code>app.controller('NavCtrl', function($scope, $location) {
    $scope.isActive = function(route) {
        return route === $location.path();
    };
})
</code></pre>

<p>If I want to test the <code>isActive</code> function, how do I do so?  I need to ensure that the <code>$location</code> service returns what is expected, and that the output of the function is what is expected.  So in our test spec we have a <code>beforeEach</code> call that gets made that sets up some local variables to hold our (controlled) version of those services, and injects them into the controller so that those are the ones to get used.  Then in our actual test we have assertions that are congruent with our expectations.  It looks like this:</p>

<pre><code>describe('NavCtrl', function() {
    var scope, $location, createController;

    beforeEach(inject(function ($rootScope, $controller _$location_) {
        $location = _$location_;
        scope = $rootScope.$new();

        createController = function() {
            return $controller('NavCtrl', {
                '$scope': scope
            });
        };
    }));

    it('should have a method to check if the path is active', function() {
        var controller = createController();
        $location.path('/about');
        expect($location.path()).toBe('/about');
        expect(scope.isActive('/about')).toBe(true);
        expect(scope.isActive('/contact')).toBe(false);
    });
});
</code></pre>

<p>With this basic structure, you can set up all kinds of stuff.  Since we are providing the controller with our own custom scope to start with, you could do stuff like setting a bunch of properties on it and then running a function you have to clear them, then make assertions that they actually were cleared.</p>

<h1><code>$httpBackend</code> Is Cool</h1>

<p>But what if you are doing stuff like using the <code>$http</code> service to call out to your server to get or post data?  Well, Angular provides a way to mock the server with a thing called <code>$httpBackend</code>.  That way, you can set up expectations for what server calls get made, or just ensure that the response can be controlled so the results of the unit tests can be consistent.</p>

<p>This looks like this:</p>

<pre><code>describe('MainCtrl', function() {
    var scope, httpBackend, createController;

    beforeEach(inject(function($rootScope, $httpBackend, $controller) {
        httpBackend = $httpBackend;
        scope = $rootScope.$new();

        createController = function() {
            return $controller('MainCtrl', {
                '$scope': scope
            });
        };
    }));

    afterEach(function() {
        httpBackend.verifyNoOutstandingExpectation();
        httpBackend.verifyNoOutstandingRequest();
    });

    it('should run the Test to get the link data from the go backend', function() {
        var controller = createController();
        scope.urlToScrape = 'success.com';

        httpBackend.expect('GET', '/slurp?urlToScrape=http:%2F%2Fsuccess.com')
            .respond({
                "success": true,
                "links": ["http://www.google.com", "http://angularjs.org", "http://amazon.com"]
            });

        // have to use $apply to trigger the $digest which will
        // take care of the HTTP request
        scope.$apply(function() {
            scope.runTest();
        });

        expect(scope.parseOriginalUrlStatus).toEqual('calling');

        httpBackend.flush();

        expect(scope.retrievedUrls).toEqual(["http://www.google.com", "http://angularjs.org", "http://amazon.com"]);
        expect(scope.parseOriginalUrlStatus).toEqual('waiting');
        expect(scope.doneScrapingOriginalUrl).toEqual(true);
    });
});
</code></pre>

<p>As you can see, the <code>beforeEach</code> call is very similar, with the only exception being we are getting <code>$httpBackend</code> from the injector rather than <code>$http</code>.  However, there are a few notable differences with how we set up the other test.  For starters, there is an <code>afterEach</code> call that ensures <code>$httpBackend</code> doesn&#8217;t have any outstanding expecations or requests after each test has been run.  And if you look at the way the test is set up and utilizes <code>$httpBackend</code>, there are a few things that are not exactly intuitive.</p>

<p>The actual call to <code>$httpBackend.expect</code> is fairly self-explanatory, but it is not in itself enough- we have to wrap our call to <code>$scope.runTest</code>, the function we are actually testing in this case, in a function that we pass to <code>$scope.$apply</code>, so that we can trigger the <code>$digest</code> which will actually take care of the HTTP request.  And as you can see, the HTTP request to <code>$httpBackend</code> will not resolve until we call <code>$httpBackend.flush()</code>, so this allows us to test what things should be like when the call is in progress but hasn&#8217;t returned yet (in the example above, the controller&#8217;s <code>$scope.parseOriginalUrlStatus</code> property will be set to <code>'calling'</code> so we can display an in-progress spinny).</p>

<p>The next few lines are assertions about properties on <code>$scope</code> that will change after the call resolves.  Pretty cool, eh?</p>

<p><em>NOTE:</em> In some places users have made it convention to have <code>scope</code> without the dollar sign when it is referenced as a var in setting up unit tests.  This doesn&#8217;t seem to be enforced or emphasized particularly strongly by the Angular docs and I find it a little bit more consistent / readable to just use <code>$scope</code> like you do everywhere else, so that&#8217;s how I&#8217;ve done things here.</p>

<h1>Conclusion</h1>

<p>Maybe this is one of those things that others just take to a bit more naturally than I do, but learning to write unit tests in Angular was pretty painful for me in the beginning.  I found my understanding of how to do so to be mostly cobbled together from various blog posts and sources around the Internet, with no real consistency or definitive best practice other than that established by natural selection.  I wanted to provide some documentation of what I eventually came up with to help other people who might be in a tight spot, and just want to get coding instead of having to learn all of the quirks and idiosyncracies of Angular and Jasmine.  So I hope this article has been of use to you.</p>

<p>Unit next week, stay sassy Internet.</p>

<ul>
<li>Nathan</li>
</ul>

]]></content>
  </entry>
  
</feed>
