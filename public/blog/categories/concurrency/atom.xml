<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: concurrency | nathan leclaire]]></title>
  <link href="http://nathanleclaire.com/blog/categories/concurrency/atom.xml" rel="self"/>
  <link href="http://nathanleclaire.com/"/>
  <updated>2014-09-29T03:13:10+00:00</updated>
  <id>http://nathanleclaire.com/</id>
  <author>
    <name><![CDATA[Nathan LeClaire]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Implementing a Concurrent Floodfill with Golang]]></title>
    <link href="http://nathanleclaire.com/blog/2014/04/05/implementing-a-concurrent-floodfill-with-golang/"/>
    <updated>2014-04-05T13:34:00+00:00</updated>
    <id>http://nathanleclaire.com/blog/2014/04/05/implementing-a-concurrent-floodfill-with-golang</id>
    <content type="html"><![CDATA[<h1>The setup</h1>

<p>Lately as part of a coding exercise I found myself implementing a <a href="http://en.wikipedia.org/wiki/Flood_fill">Flood Fill</a> for &#8220;painting&#8221; an ASCII canvas.  For those of you unfamiliar with what that is, think back to MSPaint - remember that little paint bucket that would fill a region with your color of choice?  That paint bucket implements a flood fill algorithm, although I didn&#8217;t know that&#8217;s what it was called until I started working on implementing one myself.</p>

<p><img src="/images/flood-fill/flood-fill-basic.gif"></p>

<p>My original implementation was in PHP and I had to go through a few iterations before I got to an implementation I was satisfied with.  It was surprisingly tricky to get correct as my depth-first implementation kept blowing the stack through excessive use of recursion.  A naive flood fill algorithm (depth first) looks like this:</p>

<ol>
<li>Store the color of the pixel where you are starting, then color it the new color.</li>
<li>For every adjacent pixel, if it is the same as the original color and you have never visited that pixel before, perform a flood fill on it.</li>
</ol>


<p>There are a lot of issues with this algorithm.  It takes a long time and it will quickly blow the stack if the canvas size contains more than a trivial number of pixels.</p>

<p>So I started thinking about ways to improve it, and it occurred to me to use a <em>breadth</em>-first solution instead (this is actually the kind of solution that&#8217;s visualized in the GIF above).  That way, we could store the pixels that we want to visit / fill in a queue, and visit them one at a time without blowing the stack.  It worked pretty well.</p>

<p>Just one problem, though:  It was written in PHP, and PHP is dog slow.  It&#8217;s also painfully single-threaded to boot.</p>

<h1>Go!</h1>

<p><code>&lt;s&gt;</code> Since we all know that all the cool kids use <a href="http://golang.org">Go</a> nowadays <code>&lt;/s&gt;</code>, I decided to take a crack at implementing a solution for this in Go, taking advantage of Go&#8217;s high performance and concurrency patterns.  Also, I just really like coding stuff in Go.</p>

<h2>&#8220;Canvas&#8221; abstraction</h2>

<p>The &#8220;canvas&#8221; I modeled as an two-dimensional array of byte arrays (which are chars for our purposes).  There&#8217;s another matrix that we use to keep track of which pixels we have visited before.  For convenient passing, we also have a struct <code>Node</code> that contains data about a given pixel.  We will use this later on to make our helper functions a little bit more clean looking.</p>

<pre><code class="go">type Canvas struct {
    contents [][]byte
    visited  [][]bool
}

type Node struct {
    X     int
    Y     int
    Color byte
}
</code></pre>

<p>The function to initialize the &#8220;canvas&#8221; is pretty straightforward.  We also have an analagous method, <code>setVisitedMatrixToFalse</code>, that we call before performing a flood fill operation to indicate we haven&#8217;t visited anywhere yet.</p>

<pre><code>func (c *Canvas) Init(width int, height int, blankChar byte) {
    c.contents = make([][]byte, width)
    for i := 0; i &lt; width; i++ {
        c.contents[i] = make([]byte, height)
        for j := 0; j &lt; height; j++ {
            c.contents[i][j] = blankChar
        }
    }
}
</code></pre>

<p>Called like:</p>

<pre><code>canvas := Canvas{}
canvas.Init(120, 120, '_')
</code></pre>

<p>We take advantage of easy casting from <code>[]byte</code> type to <code>string</code> for our function to print the contents of the canvas:</p>

<pre><code>func (c *Canvas) Print() {
    for _, row := range c.contents {
        fmt.Println(string(row))
    }
}
</code></pre>

<p>With this code set up, we can get into the &#8220;meat&#8221; of the flood fill algorithm.</p>

<h2>Flood Fill</h2>

<p>Instead of using pure recursion, we will instead have a &#8220;master&#8221; goroutine that forks off visits to other pixels/nodes in their own goroutines.  The child goroutines will report back their &#8220;findings&#8221; to the main goroutine, including what pixels to visit next if any.  Through the use of buffered and unbuffered goroutines, we will prevent too many visits from firing off at once, and the Go runtime scheduler will take care of juggling these activities which are running concurrently.</p>

<p>The main goroutine looks like this:</p>

<pre><code>func (c *Canvas) FloodFill(x int, y int, color byte) {
    // If unbuffered, this channel will block when we go to send the
    // initial nodes to visit (at most 4).  Not cool man.
    toVisit := make(chan Node, 4)
    visitDone := make(chan bool)

    originalColor := c.contents[x][y]

    c.setVisitedMatrixToFalse()

    go c.floodFill(x, y, color, originalColor, toVisit, visitDone)
    remainingVisits := 1

    for {
        select {
        case nextVisit := &lt;-toVisit:
            if !c.visited[nextVisit.X][nextVisit.Y] {
                c.visited[nextVisit.X][nextVisit.Y] = true
                remainingVisits++
                go c.floodFill(nextVisit.X, nextVisit.Y, color, originalColor, toVisit, visitDone)
            }
        case &lt;-visitDone:
            remainingVisits--
        default:
            if remainingVisits == 0 {
                return
            }
        }
    }
}
</code></pre>

<p>To start, we create two channels.  One is called <code>toVisit</code> and is the channel through which we send Nodes that we still want to visit (color, then check if they have neighbors we should color).  You may notice that this channel is buffered.  This is because if it is not buffered, then when we attempt to send <code>Node</code>s to visit over it, it will block and the whole program will deadlock.  Since we know that we will &#8220;queue up&#8221; at most four <code>Node</code>s into the channel (for this exercise we don&#8217;t fill pixels which are diagonally adjacent), that&#8217;s why we set our buffer size to that.  Theoretically however it will work with any buffer value greater than or equal to one.</p>

<p>The other channel is called <code>visitDone</code> and is used to indicate when a visit for a given node is finished.  We don&#8217;t care which one, since we just maintain a &#8220;one true counter&#8221; in our main routine (<code>remainingVisits</code>) that tracks how many outstanding visits we have, and ensures that the function doesn&#8217;t return as long as there are visits outstanding.  Before I implemented this solution I was getting all kinds of frustrating race conditions where the <code>default</code> block would sometimes get hit before any additional visits would get added, and so the program would exit prematurely.  If you have a better idea/solution to manage this, I&#8217;d love to hear!</p>

<p>We also keep track of the color of the original pixel, since that&#8217;s a condition of coloring (the pixels should be adjacent and the same color as the original pixel).</p>

<p>The <code>floodFill</code> method that we spin off into auxilliary goroutines looks like this:</p>

<pre><code>func (c *Canvas) floodFill(x int, y int, color byte, originalColor byte, toVisit chan Node, visitDone chan bool) {
    c.contents[x][y] = color
    neighbors := c.getNeighbors(x, y)
    for _, neighbor := range neighbors {
        if neighbor.Color == originalColor {
            toVisit &lt;- neighbor
        }
    }
    visitDone &lt;- true
}
</code></pre>

<p>I don&#8217;t know that I&#8217;m crazy about having the actual pixel coloring in this method, since it involves mutable data that&#8217;s shared between threads, so I might move it into the main method eventually, but for example purposes it works okay.  This method is fairly terse and simply colors the pixel, then calls this method to get the neighbors of the current pixel (ensuring that we don&#8217;t run over the bounds of the slice):</p>

<pre><code>func (c *Canvas) getNeighbors(x int, y int) []Node {
    var (
        neighbors []Node
        color     byte
    )
    if x+1 &lt; len(c.contents) {
        color = c.contents[x+1][y]
        neighbors = append(neighbors, Node{x + 1, y, color})
    }
    if x-1 &gt;= 0 {
        color = c.contents[x-1][y]
        neighbors = append(neighbors, Node{x - 1, y, color})
    }
    if y+1 &lt; len(c.contents[0]) {
        color = c.contents[x][y+1]
        neighbors = append(neighbors, Node{x, y + 1, color})
    }
    if y-1 &gt;= 0 {
        color = c.contents[x][y-1]
        neighbors = append(neighbors, Node{x, y - 1, color})
    }
    return neighbors
}
</code></pre>

<p>Then, we send the returned nodes over the <code>toVisit</code> channel if their color matches the original pixel&#8217;s color, and we send <code>true</code> across <code>visitDone</code> channel to indicate we are done when that is all through (this decrements our counter in the main goroutine).</p>

<p>And that&#8217;s all!</p>

<p>Check the sample output.</p>

<p>Before:</p>

<pre>
____________________
________//__________
________//_______---
__\\\\\\\\\\\\\\_---
________//_______---
________//_______---
________//_______---
_________________---
_________________---
_________________---
_________________---
_________________---
_________________---
_________________---
_________________---
_________________---
_________________---
_________________---
_________________---
_________________---
</pre>


<p>After: (filled with <code>'G'</code> char)</p>

<pre>
GGGGGGGGGGGGGGGGGGGG
GGGGGGGG//GGGGGGGGGG
GGGGGGGG//GGGGGGG---
GG\\\\\\\\\\\\\\G---
GGGGGGGG//GGGGGGG---
GGGGGGGG//GGGGGGG---
GGGGGGGG//GGGGGGG---
GGGGGGGGGGGGGGGGG---
GGGGGGGGGGGGGGGGG---
GGGGGGGGGGGGGGGGG---
GGGGGGGGGGGGGGGGG---
GGGGGGGGGGGGGGGGG---
GGGGGGGGGGGGGGGGG---
GGGGGGGGGGGGGGGGG---
GGGGGGGGGGGGGGGGG---
GGGGGGGGGGGGGGGGG---
GGGGGGGGGGGGGGGGG---
GGGGGGGGGGGGGGGGG---
GGGGGGGGGGGGGGGGG---
GGGGGGGGGGGGGGGGG---
</pre>


<p>It runs pretty satisfyingly quickly.  Wiki mentions a few alternative approaches that might work a little better (EDIT: it says that going line-by-line instead of pixel by pixel is an order of magnitude faster), but I like this one for its simplicity.</p>

<h1>Conclude</h1>

<p>The code is <a href="https://github.com/nathanleclaire/golangfloodfill">up on Github</a> if you&#8217;re curious.  I&#8217;d love to hear about other possible approaches, especially ones that are better at taking advtange of Go&#8217;s concurrency features.  I considered using <code>sync.WaitGroup</code> but this didn&#8217;t really seem like a good case to do so.</p>

<p>Until next time, stay sassy Internet.</p>

<ul>
<li>Nathan</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Wait for All Goroutines to Finish Executing Before Continuing, Part Two:  Fixing My Oops]]></title>
    <link href="http://nathanleclaire.com/blog/2014/02/21/how-to-wait-for-all-goroutines-to-finish-executing-before-continuing-part-two-fixing-my-ooops/"/>
    <updated>2014-02-21T17:03:00+00:00</updated>
    <id>http://nathanleclaire.com/blog/2014/02/21/how-to-wait-for-all-goroutines-to-finish-executing-before-continuing-part-two-fixing-my-ooops</id>
    <content type="html"><![CDATA[<p>Earlier this week I published an article called <a href="http://nathanleclaire.com/blog/2014/02/15/how-to-wait-for-all-goroutines-to-finish-executing-before-continuing/">How To Wait for All Goroutines to Finish Executing Before Continuing</a> detailing a problem that I&#8217;d run into while coding with Golang and the solution that I&#8217;d encountered, which was to use <a href="http://golang.org/pkg/sync/#WaitGroup">sync.WaitGroup</a>.  I was still basking a little in that I-just-finished-a-new-blog-article afterglow when something in the <a href="http://www.reddit.com/r/golang/comments/1y3spq/how_to_wait_for_all_goroutines_to_finish/">Reddit comments</a> caught my eye!</p>

<p><img src="/images/syncwaitgroup2/enneff_speaks.jpeg" title="Oh." ></p>

<p>Turns out that my approach in the previous article causes a race condition.  So, just so you guys are all aware, I was wrong, and here&#8217;s why.</p>

<h1>What was wrong</h1>

<p>As <a href="http://reddit.com/u/enneff">/u/enneff</a> pointed out, there are a variety of issues with the examples I provided.</p>

<h2>What was wrong with the &#8220;Old-School way&#8221; code?</h2>

<p>I&#8217;ll start at the second example (The &#8220;Old-School&#8221; way) since the first example is REALLY bad by design (please don&#8217;t write Go like that).  I used a &#8220;done&#8221; channel to communicate the status of the goroutines, and it turns out that this was completely unneccsary.</p>

<p>The original code:</p>

<pre><code class="go">package main

import (
    "fmt"
    "time"
)

func main() {
    messages := make(chan int)

    // Use this channel to follow the execution status
    // of our goroutines :D
    done := make(chan bool)

    go func() {
        time.Sleep(time.Second * 3)
        messages &lt;- 1
        done &lt;- true
    }()
    go func() {
        time.Sleep(time.Second * 2)
        messages &lt;- 2
        done &lt;- true
    }() 
    go func() {
        time.Sleep(time.Second * 1)
        messages &lt;- 3
        done &lt;- true
    }()
    go func() {
        for i := range messages {
            fmt.Println(i)
        }
    }()
    for i := 0; i &lt; 3; i++ {
        &lt;-done
    }
}
</code></pre>

<p>Thinking about it a bit, enneff&#8217;s assertion that the channel is unneeded makes a lot of sense, since you know the number of messages ahead of time.  It&#8217;s a great example of how you shouldn&#8217;t needlessly overcomplicate things (<a href="http://legacy.python.org/dev/peps/pep-0020/">simple is better than complex</a>).</p>

<pre><code class="go">package main

import (
    "fmt"
    "time"
)

func main() {
    messages := make(chan int)
    go func() {
        time.Sleep(time.Second * 3)
        messages &lt;- 1
    }()
    go func() {
        time.Sleep(time.Second * 2)
        messages &lt;- 2
    }()
    go func() {
        time.Sleep(time.Second * 1)
        messages &lt;- 3
    }()
    for i := 0; i &lt; 3; i++ {
        fmt.Println(&lt;-messages)
    }
}
</code></pre>

<p>This code is shorter, and doesn&#8217;t introduce unneeded complexity.</p>

<h2>What was wrong with the &#8220;Canonical way&#8221; code?</h2>

<p>Well, for one thing, the messages channel doesn&#8217;t get closed, which could cause a memory leak.  It&#8217;s also not exactly cosidered the best use for a <code>WaitGroup</code>.  As enneff put it:</p>

<blockquote><p>The original program leaves the printing goroutine hanging (it blocks trying to receive a fourth message that never comes). This will create a memory leak in a long-running problem. You need to close the messages channel after the wg.Wait, to make sure that goroutine terminates. Obviously not a problem in a trivial program, but we should teach good practices at all times. But that still doesn&#8217;t solve the problem of the racing and printing goroutines, and there&#8217;s no reason why the so-called &#8220;old-school&#8221; way isn&#8217;t appropriate here. When you know the number of messages to expect you might as well count them to know when to finish. Here the waitgroup is superfluous and confusing. WaitGroups are more useful for doing different tasks in parallel.</p></blockquote>

<p>More importantly, I mistakenly put the code to print the results in its own goroutine, which causes a race condition between the main goroutine and the goroutine that is printing.  In many cases, the main goroutine will win this race, which is BAD!!  Turns out that my whole &#8220;sleep for a few seconds, then send a message down the channel&#8221; example is actually not a good example for wait groups at all.</p>

<p>The &#8220;fetch some JSON from the Reddit API&#8221; example, however, actually is a good candidate for <code>sync.WaitGroup</code>, and enneff even featured a rewrite that takes advantage of multiple channels to send errors in case something goes wrong!</p>

<pre><code class="go">// This snippet was prepared in response to this article:
// http://nathanleclaire.com/blog/2014/02/15/how-to-wait-for-all-goroutines-to-finish-executing-before-continuing/
package main

import (
    "fmt"
    "io/ioutil"
    "net/http"
)

func main() {
    urls := []string{
        "http://www.reddit.com/r/aww.json",
        "http://www.reddit.com/r/funny.json",
        "http://www.reddit.com/r/programming.json",
    }

    resc, errc := make(chan string), make(chan error)

    for _, url := range urls {
        go func(url string) {
            body, err := fetch(url)
            if err != nil {
                errc &lt;- err
                return
            }
            resc &lt;- string(body)
        }(url)
    }

    for i := 0; i &lt; len(urls); i++ {
        select {
        case res := &lt;-resc:
            fmt.Println(res)
        case err := &lt;-errc:
            fmt.Println(err)
        }
    }
}

func fetch(url string) (string, error) {
    res, err := http.Get(url)
    if err != nil {
        return "", err
    }
    body, err := ioutil.ReadAll(res.Body)
    res.Body.Close()
    if err != nil {
        return "", err
    }
    return string(body), nil
}
</code></pre>

<p>Lookin&#8217; good!</p>

<h1>Conclusion</h1>

<p>All I know is that I don&#8217;t know nothing.</p>

<iframe width="420" height="315" src="//www.youtube.com/embed/5HtUnubXAO4" frameborder="0" allowfullscreen></iframe>


<p>Thanks again to <a href="https://twitter.com/enneff">Andrew Gerrand</a> for helping me to learn more about Go.  And until next time, stay sassy Internet.</p>

<ul>
<li>Nathan</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Wait for All Goroutines to Finish Executing Before Continuing]]></title>
    <link href="http://nathanleclaire.com/blog/2014/02/15/how-to-wait-for-all-goroutines-to-finish-executing-before-continuing/"/>
    <updated>2014-02-15T15:23:00+00:00</updated>
    <id>http://nathanleclaire.com/blog/2014/02/15/how-to-wait-for-all-goroutines-to-finish-executing-before-continuing</id>
    <content type="html"><![CDATA[<p><em>EDIT:</em>  As pointed out by effenn in <a href="http://www.reddit.com/r/golang/comments/1y3spq/how_to_wait_for_all_goroutines_to_finish/cfh9fg7">this Reddit comment</a>, a lot of information in this article is &#8220;dangerously inaccurate&#8221;.  OOPS!  I&#8217;ve written a followup/correction article <a href="http://nathanleclaire.com/blog/2014/02/21/how-to-wait-for-all-goroutines-to-finish-executing-before-continuing-part-two-fixing-my-ooops/">here</a> for your viewing pleasure, but I&#8217;m leaving this article up for &#8220;historical purposes&#8221;.</p>

<p><img src="/images/syncwaitgroup/gophermegaphones.jpeg"></p>

<p>Goroutines and channels are one of <a href="http://golang.org">Go</a>&#8217;s nicest language features.  They provide a rather headache-free way to use the power of concurrency in your Go programs, and they are baked into the language itself instead of relying on standard or external libraries.  I was very excited when I started playing around with them but eventually came across a problem : what if you want to wait for all goroutines (a kind of lightweight thread in case you&#8217;re not familiar) to finish executing before you continue execution in the current goroutine?</p>

<p>For instance, I came across this problem when I wanted to run a batch operation (transform some strings from a slice- kind of like a map) in parallel (and yes, I know that <a href="http://blog.golang.org/concurrency-is-not-parallelism">concurrency is not parallelism</a>).  I needed to know when this execution was over so my program didn&#8217;t exit prematurely.  How?</p>

<p>(Psst:  In case you just want the answer, and not the journey, it&#8217;s to use <a href="http://golang.org/pkg/sync/#WaitGroup">sync.WaitGroup</a>!)</p>

<p>In this article, I assume that you have some elementary proficiency with <a href="http://golang.org/doc/codewalk/sharemem/">goroutines and channels</a>.</p>

<h1>The Hacky Way</h1>

<p>A lot of tutorials or blog articles that you come across online when you start getting into this stuff will have examples like this (forgive me for being a little bit contrived but hopefully you&#8217;ll be familiar with the general idea):</p>

<pre><code class="go">package main

import (
    "fmt"
    "time"
)

func main() {
    messages := make(chan int)
    go func() {
        time.Sleep(time.Second * 3)
        messages &lt;- 1
    }()
    go func() {
        time.Sleep(time.Second * 2)
        messages &lt;- 2
    }() 
    go func() {
        time.Sleep(time.Second * 1)
        messages &lt;- 3
    }()
    go func() {
        for i := range messages {
            fmt.Println(i)
        }
    }()
    time.Sleep(time.Second * 5)
}
</code></pre>

<p>This will print out:</p>

<pre><code>3
2
1
</code></pre>

<p>because the goroutines all execute concurrently and some of the numbers sleep for longer than others.  If it weren&#8217;t for that <code>time.Sleep(time.Second * 5)</code> at the end, though, the program would terminate execution BEFORE the goroutines got a chance to finish executing and it would print nothing.</p>

<p>This kind of works for our contrived example but its hackiness makes me go &#8220;ICK!&#8221;.  Trying to make this style work in any nontrivial program would be a complete nightmare - what if we don&#8217;t know how long our goroutines will be executing for?  We&#8217;d rather not just cross our fingers and hope for the best.</p>

<h1>The &#8220;Old-School&#8221; Way</h1>

<p>As mentioned by a commenter in <a href="http://stackoverflow.com/questions/18207772/how-to-wait-for-all-goroutines-to-finish-without-using-time-sleep">this StackOverflow post</a>, the way that this was accomplished without using <code>sync.WaitGroup</code> is to use an additional channel to signify the end of execution.  Using this solution our previous example would look like:</p>

<pre><code>package main

import (
    "fmt"
    "time"
)

func main() {
    messages := make(chan int)

    // Use this channel to follow the execution status
    // of our goroutines :D
    done := make(chan bool)

    go func() {
        time.Sleep(time.Second * 3)
        messages &lt;- 1
        done &lt;- true
    }()
    go func() {
        time.Sleep(time.Second * 2)
        messages &lt;- 2
        done &lt;- true
    }() 
    go func() {
        time.Sleep(time.Second * 1)
        messages &lt;- 3
        done &lt;- true
    }()
    go func() {
        for i := range messages {
            fmt.Println(i)
        }
    }()
    for i := 0; i &lt; 3; i++ {
        &lt;-done
    }
}
</code></pre>

<p>This method is a little better but sacrifices some flexibility.  For instance, it introduces some additional weirdness in the case that we don&#8217;t actually know how many goroutines we want to spin up ahead of time.</p>

<h1>The Canonical Way</h1>

<p>As mentioned, the canonical way to do this is to use the <code>sync</code> package&#8217;s <code>WaitGroup</code> structure (<a href="http://golang.org/pkg/sync/#WaitGroup">link</a>).  From the docs:</p>

<blockquote><p>A WaitGroup waits for a collection of goroutines to finish. The main goroutine calls Add to set the number of goroutines to wait for. Then each of the goroutines runs and calls Done when finished. At the same time, Wait can be used to block until all goroutines have finished.</p></blockquote>

<p>To use <code>sync.WaitGroup</code> we:</p>

<ol>
<li>Create a new instance of a <code>sync.WaitGroup</code> (we&#8217;ll call it <code>wg</code>)</li>
<li>Call <code>wg.Add(n)</code> where <code>n</code> is the number of goroutines to wait for (we can also call <code>wg.Add(1)</code> <code>n</code> times)</li>
<li>Execute <code>defer wg.Done()</code> in each goroutine to indicate that goroutine is finished executing to the <code>WaitGroup</code> (see <a href="http://golang.org/doc/effective_go.html#defer">defer</a>)</li>
<li>Call <code>wg.Wait()</code> where we want to block.</li>
</ol>


<p>This fits our use case perfectly.  Rewritten, our code now uses <code>sync.WaitGroup</code> and looks like this:</p>

<pre><code class="go">package main

import (
    "fmt"
    "sync"
    "time"
)

func main() {
    messages := make(chan int)
    var wg sync.WaitGroup

    // you can also add these one at 
    // a time if you need to 

    wg.Add(3)
    go func() {
        defer wg.Done()
        time.Sleep(time.Second * 3)
        messages &lt;- 1
    }()
    go func() {
        defer wg.Done()
        time.Sleep(time.Second * 2)
        messages &lt;- 2
    }() 
    go func() {
        defer wg.Done()
        time.Sleep(time.Second * 1)
        messages &lt;- 3
    }()
    go func() {
        for i := range messages {
            fmt.Println(i)
        }
    }()

    wg.Wait()
}
</code></pre>

<p>This example is a little silly, but suppose we wanted to slurp JSON data from 3 different subreddits concurrently.  We don&#8217;t know how long those HTTP requests are going to take, and we don&#8217;t want to cause a race condition by trying to work with data that hasn&#8217;t been populated yet in our Go program, so <code>sync.WaitGroup</code> ends up being very handy:</p>

<pre><code class="go">package main

import (
    "fmt"
    "io/ioutil"
    "log"
    "net/http"
    "sync"
)

func main() {
    urls := []string{
        "http://www.reddit.com/r/aww.json",
        "http://www.reddit.com/r/funny.json",
        "http://www.reddit.com/r/programming.json",
    }
    jsonResponses := make(chan string)

    var wg sync.WaitGroup

    wg.Add(len(urls))

    for _, url := range urls {
        go func(url string) {
            defer wg.Done()
            res, err := http.Get(url)
            if err != nil {
                log.Fatal(err)
            } else {
                defer res.Body.Close()
                body, err := ioutil.ReadAll(res.Body)
                if err != nil {
                    log.Fatal(err)
                } else {
                    jsonResponses &lt;- string(body)
                }
            }
        }(url)
    }

    go func() {
        for response := range jsonResponses {
            fmt.Println(response)
        }
    }()

    wg.Wait()
}
</code></pre>

<p>Check out a <a href="http://runnable.com/UwEzO6LcUjMdAABH/using-sync-waitgroup-to-slurp-json-from-reddit-concurrently-wait-for-all-goroutines-to-finish-before-continuing-">Runnable</a> of this code in action!</p>

<h1>Conclusion</h1>

<p>Go is so very fun.  I need to start writing more of it again and put down this silly JavaScript stuff XD  <a href="http://martini.codegangsta.io/">Martini</a> looks super promising, so maybe I will develop and application with it.</p>

<p>Until next time, stay sassy Internet.</p>

<ul>
<li>Nathan</li>
</ul>

]]></content>
  </entry>
  
</feed>
