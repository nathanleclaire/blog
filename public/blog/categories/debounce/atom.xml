<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: debounce | nathan leclaire]]></title>
  <link href="http://nathanleclaire.com/blog/categories/debounce/atom.xml" rel="self"/>
  <link href="http://nathanleclaire.com/"/>
  <updated>2014-09-29T03:13:10+00:00</updated>
  <id>http://nathanleclaire.com/</id>
  <author>
    <name><![CDATA[Nathan LeClaire]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Write a Function Similar To Underscore.js's debounce, in Golang]]></title>
    <link href="http://nathanleclaire.com/blog/2014/08/03/write-a-function-similar-to-underscore-dot-jss-debounce-in-golang/"/>
    <updated>2014-08-03T17:22:00+00:00</updated>
    <id>http://nathanleclaire.com/blog/2014/08/03/write-a-function-similar-to-underscore-dot-jss-debounce-in-golang</id>
    <content type="html"><![CDATA[<h1>Debounce, eh?</h1>

<p><img src="/images/debouncego/debounceit.gif"></p>

<p>As some of you may recall I wrote <a href="http://nathanleclaire.com/blog/2013/11/16/the-javascript-question-i-bombed-in-an-interview-with-a-y-combinator-startup/">this post about an interview I bombed with a YCombinator Startup</a> and in it I describe how to implement a <code>debounce</code> (term taken from <a href="http://underscorejs.org/">Underscore.js</a>) type of function from scratch.  Recently I found myself having to implement a similar thing in Golang, so I&#8217;m sharing the results of my implementation here.</p>

<h2>What is it?</h2>

<p><code>debounce</code> in the Underscore.js documentation:</p>

<blockquote><p>Creates and returns a new debounced version of the passed function which will postpone its execution until after wait milliseconds have elapsed since the last time it was invoked. Useful for implementing behavior that should only happen after the input has stopped arriving. For example: rendering a preview of a Markdown comment, recalculating a layout after the window has stopped being resized, and so on.</p></blockquote>

<p><code>debounce</code> is very useful if the cost of triggering the callback function (or equivalent) for your event is quite high.  It&#8217;s a good way to get laziness for cheap if you have a busy event stream.  The example listed in the documentation is lucid:</p>

<pre><code class="js">var lazyLayout = _.debounce(calculateLayout, 300);
$(window).resize(lazyLayout);
</code></pre>

<h2>What about in Go?</h2>

<p>Go usually eschews the JavaScript callback continuation-passing style in favor of using goroutines and channels for concurrency.  It&#8217;s a very nice language feature, and elegant, but sometimes you want use a &#8220;debounce&#8221; to respond to, say, a bunch of values coming over a channel in rapid bursts.  So how do you do this in Go?</p>

<p>The answer is to use <code>time.Timer</code>&#8217;s <code>Stop</code> and <code>AfterFunc</code> methods in tandem like you would otherwise use <code>window.setTimeout</code> and <code>window.clearTimeout</code>.</p>

<p>Example code:</p>

<pre><code class="go">package main

import (
    "fmt"
    "time"
)

func debounce(interval time.Duration, f func(arg int)) func(int) {
    timer := &amp;time.Timer{}
    return func(arg int) {
        timer.Stop()
        timer = time.AfterFunc(interval, func() {
            f(arg)
        })
    }
}

func main() {
    spammyChan := make(chan int, 10)
    debouncedCostlyOperation := debounce(300*time.Millisecond, func(arg int) {
        fmt.Println("*****************************")
        fmt.Println("* DOING A COSTLY OPERATION! *")
        fmt.Println("*****************************")
        fmt.Println("In case you were wondering, the value passed to this function is", arg)
        fmt.Println("We could have more args to our \"compiled\" debounced function too, if we wanted.")
    })
    go func() {
        for {
            select {
            case spam := &lt;-spammyChan:
                fmt.Println("received a send on a spammy channel - might be doing a costly operation if not for debounce")
                debouncedCostlyOperation(spam)
            default:
            }
        }
    }()
    for i := 0; i &lt; 10; i++ {
        spammyChan &lt;- i
    }
    time.Sleep(500 * time.Millisecond)
}
</code></pre>

<p>We create a function, <code>debounce</code>, that consumes a <code>func (int)</code> and returns a <code>func(int)</code>.  Whenever we trigger this function, it will wait a specified number of milliseconds, and, if it is not interrupted by another attempt to trigger the action in that duration, it triggers the action.  If it is interrupted, it resets the timeout.</p>

<h1>fin</h1>

<p>Go is a little less flexible than JavaScript due to the strong typing (if anyone has ideas how to make this more flexible I&#8217;m very interested to hear) but this approach will get you 90% of the way there in the instances where you need debouncing.</p>

<p>Until next time, stay sassy Internet.</p>

<ul>
<li>Nathan</li>
</ul>

]]></content>
  </entry>
  
</feed>
