
<!doctype html>
<!-- START OF _layouts/default.html -->
<html style="display:none;" lang="en">
	<head>
		<meta charset="utf-8">
		<meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible" >
		<meta content="width=device-width,initial-scale=1" name="viewport">
		<meta content="I'm a solution delivery and technology expert.  I write about code (back-end and front-end), entrepreneurship, and life.  I'm obsessed with application performance, user experience, and shipping." name="description">
		<meta content="nathan leclaire" name="author">
		
		<title>Implementing a Concurrent Floodfill with Golang &mdash; nathan leclaire | I care, I share, I'm Nathan LeClaire.</title>
		
        <link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
		<link href="/stylesheets/main.css" rel="stylesheet">
		
		<script>
		   if(self == top) {
			   document.documentElement.style.display = 'block'; 
		   } else {
			   top.location = self.location; 
		   }
		</script>
		<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.0/jquery.js"></script>
		<script src="/js/jquery.modal.min.js"></script>
		<script src="/js/fuse.min.js"></script>
	</head>
	<body>
		<div class="wrap">
			<div id="sidebar">
				<header>
					<div class="title">
						<a href="http://nathanleclaire.com">
							<img src="/images/nateface.jpeg" class="nateface" /> 
							nathan leclaire 
						</a>
					</div>
					<p class="slogan">I care, I share, I'm Nathan LeClaire.</p>
					<div class="navi">
						<ul>
							<li><a href="/about/">About</a></li>
							<li><a href="/blog/archives">Archives</a></li>
							<li><a href="/atom.xml">RSS</a></li>
						</ul>
					</div> <!-- // .navi -->
					<div id="sidebar-email">
						<a href="mailto:nathan.leclaire@gmail.com">nathan.leclaire@gmail.com</a>
					</div>
				</header>
				<span id="shameless-self-promotion">
				<!-- Begin MailChimp Signup Form -->

				<div id="mc_embed_signup">
				<form action="https://nathanleclaire.us3.list-manage.com/subscribe/post?u=bb81abde21debade7a3b6c8f8&amp;id=a77a90269c" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
					<label for="mce-EMAIL">Get my essays about tech delivered to your inbox</label>
					<input type="email" value="" name="EMAIL" class="email" id="mce-EMAIL" placeholder="email@domain.com" required>
					<input type="submit" value="Go" name="subscribe" id="mc-embedded-subscribe" class="button">
					<!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
				    <div style="position: absolute; left: -5000px;"><input type="text" name="b_bb81abde21debade7a3b6c8f8_a77a90269c" value=""></div>
				</form>
				</div>
				<!--End mc_embed_signup-->
				
				<p>Quickly search the archive:</p>
				<input type="text" placeholder="Fuzzy search by keyword (e.g. Angular)" id="archive-search">
				<img src="/images/magnifying-glass.png" id="search-icon" />
				<ul id="archive-search-populate">
				</ul>
				
				</span>
			</div>
			<div id="content">
				<!-- START OF _layouts/post.html -->

<!-- START OF _includes/article.html -->
<article>
    <header>
        <h1>
            <a href="/blog/2014/04/05/implementing-a-concurrent-floodfill-with-golang/">Implementing a Concurrent Floodfill with Golang</a>
        </h1>
        <h3 style="text-align: center;">by Nathan LeClaire</h3>
        <time>05 April 2014</time>
    </header>
    <div>
        <h1>The setup</h1>

<p>Lately as part of a coding exercise I found myself implementing a <a href="http://en.wikipedia.org/wiki/Flood_fill">Flood Fill</a> for "painting" an ASCII canvas.  For those of you unfamiliar with what that is, think back to MSPaint - remember that little paint bucket that would fill a region with your color of choice?  That paint bucket implements a flood fill algorithm, although I didn't know that's what it was called until I started working on implementing one myself.</p>

<p><img src="/images/flood-fill/flood-fill-basic.gif"></p>

<p>My original implementation was in PHP and I had to go through a few iterations before I got to an implementation I was satisfied with.  It was surprisingly tricky to get correct as my depth-first implementation kept blowing the stack through excessive use of recursion.  A naive flood fill algorithm (depth first) looks like this:</p>

<ol>
<li>Store the color of the pixel where you are starting, then color it the new color.</li>
<li>For every adjacent pixel, if it is the same as the original color and you have never visited that pixel before, perform a flood fill on it.</li>
</ol>


<p>There are a lot of issues with this algorithm.  It takes a long time and it will quickly blow the stack if the canvas size contains more than a trivial number of pixels.</p>

<p>So I started thinking about ways to improve it, and it occurred to me to use a <em>breadth</em>-first solution instead (this is actually the kind of solution that's visualized in the GIF above).  That way, we could store the pixels that we want to visit / fill in a queue, and visit them one at a time without blowing the stack.  It worked pretty well.</p>

<p>Just one problem, though:  It was written in PHP, and PHP is dog slow.  It's also painfully single-threaded to boot.</p>

<h1>Go!</h1>

<p><code>&lt;s&gt;</code> Since we all know that all the cool kids use <a href="http://golang.org">Go</a> nowadays <code>&lt;/s&gt;</code>, I decided to take a crack at implementing a solution for this in Go, taking advantage of Go's high performance and concurrency patterns.  Also, I just really like coding stuff in Go.</p>

<h2>"Canvas" abstraction</h2>

<p>The "canvas" I modeled as an two-dimensional array of byte arrays (which are chars for our purposes).  There's another matrix that we use to keep track of which pixels we have visited before.  For convenient passing, we also have a struct <code>Node</code> that contains data about a given pixel.  We will use this later on to make our helper functions a little bit more clean looking.</p>

<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span></span></figcaption><pre class=go><code>type Canvas struct {
    contents [][]byte
    visited  [][]bool
}

type Node struct {
    X     int
    Y     int
    Color byte
}</code></pre></figure></notextile></div>


<p>The function to initialize the "canvas" is pretty straightforward.  We also have an analagous method, <code>setVisitedMatrixToFalse</code>, that we call before performing a flood fill operation to indicate we haven't visited anywhere yet.</p>

<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span></span></figcaption><pre class=go><code>func (c *Canvas) Init(width int, height int, blankChar byte) {
    c.contents = make([][]byte, width)
    for i := 0; i &lt; width; i++ {
        c.contents[i] = make([]byte, height)
        for j := 0; j &lt; height; j++ {
            c.contents[i][j] = blankChar
        }
    }
}</code></pre></figure></notextile></div>


<p>Called like:</p>

<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span></span></figcaption><pre class=go><code>canvas := Canvas{}
canvas.Init(120, 120, '_')</code></pre></figure></notextile></div>


<p>We take advantage of easy casting from <code>[]byte</code> type to <code>string</code> for our function to print the contents of the canvas:</p>

<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span></span></figcaption><pre class=go><code>func (c *Canvas) Print() {
    for _, row := range c.contents {
        fmt.Println(string(row))
    }
}</code></pre></figure></notextile></div>


<p>With this code set up, we can get into the "meat" of the flood fill algorithm.</p>

<h2>Flood Fill</h2>

<p>Instead of using pure recursion, we will instead have a "master" goroutine that forks off visits to other pixels/nodes in their own goroutines.  The child goroutines will report back their "findings" to the main goroutine, including what pixels to visit next if any.  Through the use of buffered and unbuffered goroutines, we will prevent too many visits from firing off at once, and the Go runtime scheduler will take care of juggling these activities which are running concurrently.</p>

<p>The main goroutine looks like this:</p>

<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span></span></figcaption><pre class=go><code>func (c *Canvas) FloodFill(x int, y int, color byte) {
    // If unbuffered, this channel will block when we go to send the
    // initial nodes to visit (at most 4).  Not cool man.
    toVisit := make(chan Node, 4)
    visitDone := make(chan bool)

    originalColor := c.contents[x][y]

    c.setVisitedMatrixToFalse()

    go c.floodFill(x, y, color, originalColor, toVisit, visitDone)
    remainingVisits := 1

    for {
        select {
        case nextVisit := &lt;-toVisit:
            if !c.visited[nextVisit.X][nextVisit.Y] {
                c.visited[nextVisit.X][nextVisit.Y] = true
                remainingVisits++
                go c.floodFill(nextVisit.X, nextVisit.Y, color, originalColor, toVisit, visitDone)
            }
        case &lt;-visitDone:
            remainingVisits--
        default:
            if remainingVisits == 0 {
                return
            }
        }
    }
}</code></pre></figure></notextile></div>


<p>To start, we create two channels.  One is called <code>toVisit</code> and is the channel through which we send Nodes that we still want to visit (color, then check if they have neighbors we should color).  You may notice that this channel is buffered.  This is because if it is not buffered, then when we attempt to send <code>Node</code>s to visit over it, it will block and the whole program will deadlock.  Since we know that we will "queue up" at most four <code>Node</code>s into the channel (for this exercise we don't fill pixels which are diagonally adjacent), that's why we set our buffer size to that.  Theoretically however it will work with any buffer value greater than or equal to one.</p>

<p>The other channel is called <code>visitDone</code> and is used to indicate when a visit for a given node is finished.  We don't care which one, since we just maintain a "one true counter" in our main routine (<code>remainingVisits</code>) that tracks how many outstanding visits we have, and ensures that the function doesn't return as long as there are visits outstanding.  Before I implemented this solution I was getting all kinds of frustrating race conditions where the <code>default</code> block would sometimes get hit before any additional visits would get added, and so the program would exit prematurely.  If you have a better idea/solution to manage this, I'd love to hear!</p>

<p>We also keep track of the color of the original pixel, since that's a condition of coloring (the pixels should be adjacent and the same color as the original pixel).</p>

<p>The <code>floodFill</code> method that we spin off into auxilliary goroutines looks like this:</p>

<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span></span></figcaption><pre class=go><code>func (c *Canvas) floodFill(x int, y int, color byte, originalColor byte, toVisit chan Node, visitDone chan bool) {
    c.contents[x][y] = color
    neighbors := c.getNeighbors(x, y)
    for _, neighbor := range neighbors {
        if neighbor.Color == originalColor {
            toVisit &lt;- neighbor
        }
    }
    visitDone &lt;- true
}</code></pre></figure></notextile></div>


<p>I don't know that I'm crazy about having the actual pixel coloring in this method, since it involves mutable data that's shared between threads, so I might move it into the main method eventually, but for example purposes it works okay.  This method is fairly terse and simply colors the pixel, then calls this method to get the neighbors of the current pixel (ensuring that we don't run over the bounds of the slice):</p>

<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span></span></figcaption><pre class=go><code>func (c *Canvas) getNeighbors(x int, y int) []Node {
    var (
        neighbors []Node
        color     byte
    )
    if x+1 &lt; len(c.contents) {
        color = c.contents[x+1][y]
        neighbors = append(neighbors, Node{x + 1, y, color})
    }
    if x-1 &gt;= 0 {
        color = c.contents[x-1][y]
        neighbors = append(neighbors, Node{x - 1, y, color})
    }
    if y+1 &lt; len(c.contents[0]) {
        color = c.contents[x][y+1]
        neighbors = append(neighbors, Node{x, y + 1, color})
    }
    if y-1 &gt;= 0 {
        color = c.contents[x][y-1]
        neighbors = append(neighbors, Node{x, y - 1, color})
    }
    return neighbors
}</code></pre></figure></notextile></div>


<p>Then, we send the returned nodes over the <code>toVisit</code> channel if their color matches the original pixel's color, and we send <code>true</code> across <code>visitDone</code> channel to indicate we are done when that is all through (this decrements our counter in the main goroutine).</p>

<p>And that's all!</p>

<p>Check the sample output.</p>

<p>Before:</p>

<pre>
____________________
________//__________
________//_______---
__\\\\\\\\\\\\\\_---
________//_______---
________//_______---
________//_______---
_________________---
_________________---
_________________---
_________________---
_________________---
_________________---
_________________---
_________________---
_________________---
_________________---
_________________---
_________________---
_________________---
</pre>


<p>After: (filled with <code>'G'</code> char)</p>

<pre>
GGGGGGGGGGGGGGGGGGGG
GGGGGGGG//GGGGGGGGGG
GGGGGGGG//GGGGGGG---
GG\\\\\\\\\\\\\\G---
GGGGGGGG//GGGGGGG---
GGGGGGGG//GGGGGGG---
GGGGGGGG//GGGGGGG---
GGGGGGGGGGGGGGGGG---
GGGGGGGGGGGGGGGGG---
GGGGGGGGGGGGGGGGG---
GGGGGGGGGGGGGGGGG---
GGGGGGGGGGGGGGGGG---
GGGGGGGGGGGGGGGGG---
GGGGGGGGGGGGGGGGG---
GGGGGGGGGGGGGGGGG---
GGGGGGGGGGGGGGGGG---
GGGGGGGGGGGGGGGGG---
GGGGGGGGGGGGGGGGG---
GGGGGGGGGGGGGGGGG---
GGGGGGGGGGGGGGGGG---
</pre>


<p>It runs pretty satisfyingly quickly.  Wiki mentions a few alternative approaches that might work a little better (EDIT: it says that going line-by-line instead of pixel by pixel is an order of magnitude faster), but I like this one for its simplicity.</p>

<h1>Conclude</h1>

<p>The code is <a href="https://github.com/nathanleclaire/golangfloodfill">up on Github</a> if you're curious.  I'd love to hear about other possible approaches, especially ones that are better at taking advtange of Go's concurrency features.  I considered using <code>sync.WaitGroup</code> but this didn't really seem like a good case to do so.</p>

<p>Until next time, stay sassy Internet.</p>

<ul>
<li>Nathan</li>
</ul>


    </div>
    <footer>
        <p>If you find a mistake or issue in this article, please <a id="pull-request-link" taget="_blank" href="">fix it and submit a pull request on Github</a> (must be signed in to your GitHub account).</p>
        <a target="_blank" style="display: block;" href="https://twitter.com/share?url=http://nathanleclaire.com/blog/2014/04/05/implementing-a-concurrent-floodfill-with-golang/&text=Great article from @upthecyberpunks : " class="social-media-spam">Tweet It</a>
        <a target="_blank" href="https://news.ycombinator.com/submitlink?u=http://nathanleclaire.com/blog/2014/04/05/implementing-a-concurrent-floodfill-with-golang/&t=" class="social-media-spam">Submit to Hacker News</a>
        <a target="_blank" style="display: block !important;" href="http://www.reddit.com/submit?url=http://nathanleclaire.com/blog/2014/04/05/implementing-a-concurrent-floodfill-with-golang/&title=" class="social-media-spam">Submit to Reddit</a>
        <br>


		



  
		
			Tagged under
		
    <a class='category' href='/blog/categories/algorithms/'>algorithms</a>, <a class='category' href='/blog/categories/concurrency/'>concurrency</a>, <a class='category' href='/blog/categories/floodfill/'>floodfill</a>, <a class='category' href='/blog/categories/golang/'>golang</a>
	

 

        <a target="_blank" style="display: block !important;" href="http://discourse.nathanleclaire.com">Chat in the forum!!</a>
    
        <div id="discourse-comments"></div>
    </footer>
    
</article>
<!-- END OF _includes/article.html -->


<!-- END OF _/layouts/post.html -->

			</div>
			<form class="modal" id="mailing-list-modal" action="http://nathanleclaire.us3.list-manage.com/subscribe/post?u=bb81abde21debade7a3b6c8f8&amp;id=a77a90269c" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
					<h1>Like what you're reading?</h1>
					<img src="/images/happy-reader.jpeg"></img>
					<p style="display: block;" for="mce-EMAIL">Did you enjoy this article?  You might want to sign up for my mailing list.  I send out weekly-ish essays about hot new tech stuff.</p>
					<input type="email" value="" name="EMAIL" class="email" id="mce-EMAIL-modal" placeholder="email@domain.com" required>
					<input type="submit" value="Go" name="subscribe" id="mc-embedded-subscribe" class="button">
					<!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
				    <div style="position: absolute; left: -5000px;"><input type="text" name="b_bb81abde21debade7a3b6c8f8_a77a90269c" value=""></div>
			</form>
		</div> <!-- // .wrap -->
	<script type="text/javascript" src="/js/prettify.js"></script>
	<script>
	function supports_html5_storage() {
	  try {
		return 'localStorage' in window && window['localStorage'] !== null;
	  } catch (e) {
		return false;
	  }
	}

	$(document).ready(function () {
	    var fuse;

	    $("code").addClass("prettyprint");
	    prettyPrint();

	    $.getJSON("/articles.json", function(data) {
	    	// input:
	    	// [{title: "Learn Node.js The Troll Way", href: "blahblah"}, { ... }]
	    	fuse = new Fuse(data, {
	    	    keys: ['title', 'tags']
	    	});
	    });
	    
	    $("#archive-search").keyup(function() {
	    	var $this = $(this);
	    	var val = $this.val();
	    	var result = fuse.search(val).slice(0, 1);
	    	$list = $("#archive-search-populate");
	    	$list.empty();
	    	if (result.length > 0 && val !== '') {
	    	    $.each(result, function(i, e) {
	    	        $list.append('<li><a href="'+ e.href +'">'+ e.title +'</a></li>');
	    	    });
	    	}
	    });
	    
	    $(".social-media-spam").each(function () {
	        var e = $(this);
	        var t = e.attr("href");
	        var n = $("article header h1 a").html();
	        t += encodeURIComponent(n);
	        e.attr("href", t)
	    });

	    var e = window.location.href;
	    var t = $("#pull-request-link");
	    var n = "https://github.com/nathanleclaire/blog/edit/master/source/_posts/" + e.split("/").slice(4, 8).join("-") + ".markdown";
	    t.attr("href", n);

	    // Only offer mailing list once
		var tryModal = localStorage["modal"] ? false : true;

		// Don't offer mailing list to people on mobile
		if ($(window).width() < 720) {
			tryModal = false;
		}

		$('#mc-embedded-subscribe').click(function() {
			// Don't offer mailing list if people have
			// already clicked to try and sign up
			tryModal = false;
			localStorage["modal"] = "true";
		});

		$(window).scroll(function () {
			if (tryModal && document.URL.indexOf('archives') === -1 && document.URL.indexOf('about') === -1) {
				if (($(window).scrollTop() + $(window).height()) === $(document).height()) {
					if (supports_html5_storage()) {
						window.setTimeout(function() {
							$('#mailing-list-modal').modal({
								fadeDuration: 250
							});
							$('#mce-EMAIL-modal').focus();
							tryModal = false;
							localStorage["modal"] = "true";
						}, 1000);
					}
				}
			}
		});


	});
	</script>
	<script type="text/javascript">
	if ('/blog/2014/04/05/implementing-a-concurrent-floodfill-with-golang/' !== '/blog/index.html') {
	  var discourseUrl = "http://discourse.nathanleclaire.com/",
	      discourseEmbedUrl = 'http://nathanleclaire.com/blog/2014/04/05/implementing-a-concurrent-floodfill-with-golang/';

	  (function() {
	    var d = document.createElement('script'); d.type = 'text/javascript'; d.async = true;
	      d.src = discourseUrl + 'javascripts/embed.js';
	    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(d);
	  })();
	}
	</script>
	<script>
	  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
	  ga('create', 'UA-26758702-2', 'nathanleclaire.com');
	  ga('send', 'pageview');
	</script>
	</body>
</html>
<!-- END OF _layouts/default.html -->
