
<!doctype html>
<!-- START OF _layouts/default.html -->
<html style="display:none;" lang="en">
	<head>
		<meta charset="utf-8">
		<meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible" >
		<meta content="width=device-width,initial-scale=1" name="viewport">
		<meta content="I'm a solution delivery and technology expert.  I write about code (back-end and front-end), entrepreneurship, and life.  I'm obsessed with application performance, user experience, and shipping." name="description">
		<meta content="nathan leclaire" name="author">
		
		<title>How to Wait for All Goroutines to Finish Executing Before Continuing &mdash; nathan leclaire | I care, I share, I'm Nathan LeClaire.</title>
		
        <link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
		<link href="/stylesheets/main.css" rel="stylesheet">
		
		<script>
		   if(self == top) {
			   document.documentElement.style.display = 'block'; 
		   } else {
			   top.location = self.location; 
		   }
		</script>
		<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.0/jquery.js"></script>
		<script src="/js/jquery.modal.min.js"></script>
		<script src="/js/fuse.min.js"></script>
	</head>
	<body>
		<div class="wrap">
			<div id="sidebar">
				<header>
					<div class="title">
						<a href="http://nathanleclaire.com">
							<img src="/images/nateface.jpeg" class="nateface" /> 
							nathan leclaire 
						</a>
					</div>
					<p class="slogan">I care, I share, I'm Nathan LeClaire.</p>
					<div class="navi">
						<ul>
							<li><a href="/about/">About</a></li>
							<li><a href="/blog/archives">Archives</a></li>
							<li><a href="/atom.xml">RSS</a></li>
						</ul>
					</div> <!-- // .navi -->
					<div id="sidebar-email">
						<a href="mailto:nathan.leclaire@gmail.com">nathan.leclaire@gmail.com</a>
					</div>
				</header>
				<span id="shameless-self-promotion">
				<!-- Begin MailChimp Signup Form -->

				<div id="mc_embed_signup">
				<form action="https://nathanleclaire.us3.list-manage.com/subscribe/post?u=bb81abde21debade7a3b6c8f8&amp;id=a77a90269c" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
					<label for="mce-EMAIL">Get my essays about tech delivered to your inbox</label>
					<input type="email" value="" name="EMAIL" class="email" id="mce-EMAIL" placeholder="email@domain.com" required>
					<input type="submit" value="Go" name="subscribe" id="mc-embedded-subscribe" class="button">
					<!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
				    <div style="position: absolute; left: -5000px;"><input type="text" name="b_bb81abde21debade7a3b6c8f8_a77a90269c" value=""></div>
				</form>
				</div>
				<!--End mc_embed_signup-->
				
				<p>Quickly search the archive:</p>
				<input type="text" placeholder="Fuzzy search by keyword (e.g. Angular)" id="archive-search">
				<img src="/images/magnifying-glass.png" id="search-icon" />
				<ul id="archive-search-populate">
				</ul>
				
				</span>
			</div>
			<div id="content">
				<!-- START OF _layouts/post.html -->

<!-- START OF _includes/article.html -->
<article>
    <header>
        <h1>
            <a href="/blog/2014/02/15/how-to-wait-for-all-goroutines-to-finish-executing-before-continuing/">How to Wait for All Goroutines to Finish Executing Before Continuing</a>
        </h1>
        <h3 style="text-align: center;">by Nathan LeClaire</h3>
        <time>15 February 2014</time>
    </header>
    <div>
        <p><em>EDIT:</em>  As pointed out by effenn in <a href="http://www.reddit.com/r/golang/comments/1y3spq/how_to_wait_for_all_goroutines_to_finish/cfh9fg7">this Reddit comment</a>, a lot of information in this article is "dangerously inaccurate".  OOPS!  I've written a followup/correction article <a href="http://nathanleclaire.com/blog/2014/02/21/how-to-wait-for-all-goroutines-to-finish-executing-before-continuing-part-two-fixing-my-ooops/">here</a> for your viewing pleasure, but I'm leaving this article up for "historical purposes".</p>

<p><img src="/images/syncwaitgroup/gophermegaphones.jpeg"></p>

<p>Goroutines and channels are one of <a href="http://golang.org">Go</a>'s nicest language features.  They provide a rather headache-free way to use the power of concurrency in your Go programs, and they are baked into the language itself instead of relying on standard or external libraries.  I was very excited when I started playing around with them but eventually came across a problem : what if you want to wait for all goroutines (a kind of lightweight thread in case you're not familiar) to finish executing before you continue execution in the current goroutine?</p>

<p>For instance, I came across this problem when I wanted to run a batch operation (transform some strings from a slice- kind of like a map) in parallel (and yes, I know that <a href="http://blog.golang.org/concurrency-is-not-parallelism">concurrency is not parallelism</a>).  I needed to know when this execution was over so my program didn't exit prematurely.  How?</p>

<p>(Psst:  In case you just want the answer, and not the journey, it's to use <a href="http://golang.org/pkg/sync/#WaitGroup">sync.WaitGroup</a>!)</p>

<p>In this article, I assume that you have some elementary proficiency with <a href="http://golang.org/doc/codewalk/sharemem/">goroutines and channels</a>.</p>

<h1>The Hacky Way</h1>

<p>A lot of tutorials or blog articles that you come across online when you start getting into this stuff will have examples like this (forgive me for being a little bit contrived but hopefully you'll be familiar with the general idea):</p>

<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span></span></figcaption><pre class=go><code>package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() {
    messages := make(chan int)
    go func() {
        time.Sleep(time.Second * 3)
        messages &lt;- 1
    }()
    go func() {
        time.Sleep(time.Second * 2)
        messages &lt;- 2
    }() 
    go func() {
        time.Sleep(time.Second * 1)
        messages &lt;- 3
    }()
    go func() {
        for i := range messages {
            fmt.Println(i)
        }
    }()
    time.Sleep(time.Second * 5)
}</code></pre></figure></notextile></div>


<p>This will print out:</p>

<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span></span></figcaption><pre class=go><code>3
2
1</code></pre></figure></notextile></div>


<p>because the goroutines all execute concurrently and some of the numbers sleep for longer than others.  If it weren't for that <code>time.Sleep(time.Second * 5)</code> at the end, though, the program would terminate execution BEFORE the goroutines got a chance to finish executing and it would print nothing.</p>

<p>This kind of works for our contrived example but its hackiness makes me go "ICK!".  Trying to make this style work in any nontrivial program would be a complete nightmare - what if we don't know how long our goroutines will be executing for?  We'd rather not just cross our fingers and hope for the best.</p>

<h1>The "Old-School" Way</h1>

<p>As mentioned by a commenter in <a href="http://stackoverflow.com/questions/18207772/how-to-wait-for-all-goroutines-to-finish-without-using-time-sleep">this StackOverflow post</a>, the way that this was accomplished without using <code>sync.WaitGroup</code> is to use an additional channel to signify the end of execution.  Using this solution our previous example would look like:</p>

<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span></span></figcaption><pre class=go><code>package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() {
    messages := make(chan int)

    // Use this channel to follow the execution status
    // of our goroutines :D
    done := make(chan bool)

    go func() {
        time.Sleep(time.Second * 3)
        messages &lt;- 1
        done &lt;- true
    }()
    go func() {
        time.Sleep(time.Second * 2)
        messages &lt;- 2
        done &lt;- true
    }() 
    go func() {
        time.Sleep(time.Second * 1)
        messages &lt;- 3
        done &lt;- true
    }()
    go func() {
        for i := range messages {
            fmt.Println(i)
        }
    }()
    for i := 0; i &lt; 3; i++ {
        &lt;-done
    }
}</code></pre></figure></notextile></div>


<p>This method is a little better but sacrifices some flexibility.  For instance, it introduces some additional weirdness in the case that we don't actually know how many goroutines we want to spin up ahead of time.</p>

<h1>The Canonical Way</h1>

<p>As mentioned, the canonical way to do this is to use the <code>sync</code> package's <code>WaitGroup</code> structure (<a href="http://golang.org/pkg/sync/#WaitGroup">link</a>).  From the docs:</p>

<blockquote><p>A WaitGroup waits for a collection of goroutines to finish. The main goroutine calls Add to set the number of goroutines to wait for. Then each of the goroutines runs and calls Done when finished. At the same time, Wait can be used to block until all goroutines have finished.</p></blockquote>

<p>To use <code>sync.WaitGroup</code> we:</p>

<ol>
<li>Create a new instance of a <code>sync.WaitGroup</code> (we'll call it <code>wg</code>)</li>
<li>Call <code>wg.Add(n)</code> where <code>n</code> is the number of goroutines to wait for (we can also call <code>wg.Add(1)</code> <code>n</code> times)</li>
<li>Execute <code>defer wg.Done()</code> in each goroutine to indicate that goroutine is finished executing to the <code>WaitGroup</code> (see <a href="http://golang.org/doc/effective_go.html#defer">defer</a>)</li>
<li>Call <code>wg.Wait()</code> where we want to block.</li>
</ol>


<p>This fits our use case perfectly.  Rewritten, our code now uses <code>sync.WaitGroup</code> and looks like this:</p>

<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span></span></figcaption><pre class=go><code>package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
    &quot;time&quot;
)

func main() {
    messages := make(chan int)
    var wg sync.WaitGroup

    // you can also add these one at 
    // a time if you need to 

    wg.Add(3)
    go func() {
        defer wg.Done()
        time.Sleep(time.Second * 3)
        messages &lt;- 1
    }()
    go func() {
        defer wg.Done()
        time.Sleep(time.Second * 2)
        messages &lt;- 2
    }() 
    go func() {
        defer wg.Done()
        time.Sleep(time.Second * 1)
        messages &lt;- 3
    }()
    go func() {
        for i := range messages {
            fmt.Println(i)
        }
    }()

    wg.Wait()
}</code></pre></figure></notextile></div>


<p>This example is a little silly, but suppose we wanted to slurp JSON data from 3 different subreddits concurrently.  We don't know how long those HTTP requests are going to take, and we don't want to cause a race condition by trying to work with data that hasn't been populated yet in our Go program, so <code>sync.WaitGroup</code> ends up being very handy:</p>

<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span></span></figcaption><pre class=go><code>package main

import (
    &quot;fmt&quot;
    &quot;io/ioutil&quot;
    &quot;log&quot;
    &quot;net/http&quot;
    &quot;sync&quot;
)

func main() {
    urls := []string{
        &quot;http://www.reddit.com/r/aww.json&quot;,
        &quot;http://www.reddit.com/r/funny.json&quot;,
        &quot;http://www.reddit.com/r/programming.json&quot;,
    }
    jsonResponses := make(chan string)

    var wg sync.WaitGroup

    wg.Add(len(urls))

    for _, url := range urls {
        go func(url string) {
            defer wg.Done()
            res, err := http.Get(url)
            if err != nil {
                log.Fatal(err)
            } else {
                defer res.Body.Close()
                body, err := ioutil.ReadAll(res.Body)
                if err != nil {
                    log.Fatal(err)
                } else {
                    jsonResponses &lt;- string(body)
                }
            }
        }(url)
    }

    go func() {
        for response := range jsonResponses {
            fmt.Println(response)
        }
    }()

    wg.Wait()
}</code></pre></figure></notextile></div>


<p>Check out a <a href="http://runnable.com/UwEzO6LcUjMdAABH/using-sync-waitgroup-to-slurp-json-from-reddit-concurrently-wait-for-all-goroutines-to-finish-before-continuing-">Runnable</a> of this code in action!</p>

<h1>Conclusion</h1>

<p>Go is so very fun.  I need to start writing more of it again and put down this silly JavaScript stuff XD  <a href="http://martini.codegangsta.io/">Martini</a> looks super promising, so maybe I will develop and application with it.</p>

<p>Until next time, stay sassy Internet.</p>

<ul>
<li>Nathan</li>
</ul>


    </div>
    <footer>
        <p>If you find a mistake or issue in this article, please <a id="pull-request-link" taget="_blank" href="">fix it and submit a pull request on Github</a> (must be signed in to your GitHub account).</p>
        <a target="_blank" style="display: block;" href="https://twitter.com/share?url=http://nathanleclaire.com/blog/2014/02/15/how-to-wait-for-all-goroutines-to-finish-executing-before-continuing/&text=Great article from @upthecyberpunks : " class="social-media-spam">Tweet It</a>
        <a target="_blank" href="https://news.ycombinator.com/submitlink?u=http://nathanleclaire.com/blog/2014/02/15/how-to-wait-for-all-goroutines-to-finish-executing-before-continuing/&t=" class="social-media-spam">Submit to Hacker News</a>
        <a target="_blank" style="display: block !important;" href="http://www.reddit.com/submit?url=http://nathanleclaire.com/blog/2014/02/15/how-to-wait-for-all-goroutines-to-finish-executing-before-continuing/&title=" class="social-media-spam">Submit to Reddit</a>
        <br>


		



  
		
			Tagged under
		
    <a class='category' href='/blog/categories/concurrency/'>concurrency</a>, <a class='category' href='/blog/categories/golang/'>golang</a>, <a class='category' href='/blog/categories/goroutines/'>goroutines</a>, <a class='category' href='/blog/categories/sync/'>sync</a>, <a class='category' href='/blog/categories/waitgroup/'>waitgroup</a>
	

 

        <a target="_blank" style="display: block !important;" href="http://discourse.nathanleclaire.com">Chat in the forum!!</a>
    
        <div id="discourse-comments"></div>
    </footer>
    
</article>
<!-- END OF _includes/article.html -->


<!-- END OF _/layouts/post.html -->

			</div>
			<form class="modal" id="mailing-list-modal" action="http://nathanleclaire.us3.list-manage.com/subscribe/post?u=bb81abde21debade7a3b6c8f8&amp;id=a77a90269c" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
					<h1>Like what you're reading?</h1>
					<img src="/images/happy-reader.jpeg"></img>
					<p style="display: block;" for="mce-EMAIL">Did you enjoy this article?  You might want to sign up for my mailing list.  I send out weekly-ish essays about hot new tech stuff.</p>
					<input type="email" value="" name="EMAIL" class="email" id="mce-EMAIL-modal" placeholder="email@domain.com" required>
					<input type="submit" value="Go" name="subscribe" id="mc-embedded-subscribe" class="button">
					<!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
				    <div style="position: absolute; left: -5000px;"><input type="text" name="b_bb81abde21debade7a3b6c8f8_a77a90269c" value=""></div>
			</form>
		</div> <!-- // .wrap -->
	<script type="text/javascript" src="/js/prettify.js"></script>
	<script>
	function supports_html5_storage() {
	  try {
		return 'localStorage' in window && window['localStorage'] !== null;
	  } catch (e) {
		return false;
	  }
	}

	$(document).ready(function () {
	    var fuse;

	    $("code").addClass("prettyprint");
	    prettyPrint();

	    $.getJSON("/articles.json", function(data) {
	    	// input:
	    	// [{title: "Learn Node.js The Troll Way", href: "blahblah"}, { ... }]
	    	fuse = new Fuse(data, {
	    	    keys: ['title', 'tags']
	    	});
	    });
	    
	    $("#archive-search").keyup(function() {
	    	var $this = $(this);
	    	var val = $this.val();
	    	var result = fuse.search(val).slice(0, 1);
	    	$list = $("#archive-search-populate");
	    	$list.empty();
	    	if (result.length > 0 && val !== '') {
	    	    $.each(result, function(i, e) {
	    	        $list.append('<li><a href="'+ e.href +'">'+ e.title +'</a></li>');
	    	    });
	    	}
	    });
	    
	    $(".social-media-spam").each(function () {
	        var e = $(this);
	        var t = e.attr("href");
	        var n = $("article header h1 a").html();
	        t += encodeURIComponent(n);
	        e.attr("href", t)
	    });

	    var e = window.location.href;
	    var t = $("#pull-request-link");
	    var n = "https://github.com/nathanleclaire/blog/edit/master/source/_posts/" + e.split("/").slice(4, 8).join("-") + ".markdown";
	    t.attr("href", n);

	    // Only offer mailing list once
		var tryModal = localStorage["modal"] ? false : true;

		// Don't offer mailing list to people on mobile
		if ($(window).width() < 720) {
			tryModal = false;
		}

		$('#mc-embedded-subscribe').click(function() {
			// Don't offer mailing list if people have
			// already clicked to try and sign up
			tryModal = false;
			localStorage["modal"] = "true";
		});

		$(window).scroll(function () {
			if (tryModal && document.URL.indexOf('archives') === -1 && document.URL.indexOf('about') === -1) {
				if (($(window).scrollTop() + $(window).height()) === $(document).height()) {
					if (supports_html5_storage()) {
						window.setTimeout(function() {
							$('#mailing-list-modal').modal({
								fadeDuration: 250
							});
							$('#mce-EMAIL-modal').focus();
							tryModal = false;
							localStorage["modal"] = "true";
						}, 1000);
					}
				}
			}
		});


	});
	</script>
	<script type="text/javascript">
	if ('/blog/2014/02/15/how-to-wait-for-all-goroutines-to-finish-executing-before-continuing/' !== '/blog/index.html') {
	  var discourseUrl = "http://discourse.nathanleclaire.com/",
	      discourseEmbedUrl = 'http://nathanleclaire.com/blog/2014/02/15/how-to-wait-for-all-goroutines-to-finish-executing-before-continuing/';

	  (function() {
	    var d = document.createElement('script'); d.type = 'text/javascript'; d.async = true;
	      d.src = discourseUrl + 'javascripts/embed.js';
	    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(d);
	  })();
	}
	</script>
	<script>
	  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
	  ga('create', 'UA-26758702-2', 'nathanleclaire.com');
	  ga('send', 'pageview');
	</script>
	</body>
</html>
<!-- END OF _layouts/default.html -->
