
<!doctype html>
<!-- START OF _layouts/default.html -->
<html style="display:none;" lang="en">
	<head>
		<meta charset="utf-8">
		<meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible" >
		<meta content="width=device-width,initial-scale=1" name="viewport">
		<meta content="I'm a solution delivery and technology expert.  I write about code (back-end and front-end), entrepreneurship, and life.  I'm obsessed with application performance, user experience, and shipping." name="description">
		<meta content="nathan leclaire" name="author">
		
		<title>How to Wait for All Goroutines to Finish Executing Before Continuing, Part Two:  Fixing My Oops &mdash; nathan leclaire | I care, I share, I'm Nathan LeClaire.</title>
		
        <link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
		<link href="/stylesheets/main.css" rel="stylesheet">
		
		<script>
		   if(self == top) {
			   document.documentElement.style.display = 'block'; 
		   } else {
			   top.location = self.location; 
		   }
		</script>
		<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.0/jquery.js"></script>
		<script src="/js/jquery.modal.min.js"></script>
		<script src="/js/fuse.min.js"></script>
	</head>
	<body>
		<div class="wrap">
			<div id="sidebar">
				<header>
					<div class="title">
						<a href="http://nathanleclaire.com">
							<img src="/images/nateface.jpeg" class="nateface" /> 
							nathan leclaire 
						</a>
					</div>
					<p class="slogan">I care, I share, I'm Nathan LeClaire.</p>
					<div class="navi">
						<ul>
							<li><a href="/about/">About</a></li>
							<li><a href="/blog/archives">Archives</a></li>
							<li><a href="/atom.xml">RSS</a></li>
						</ul>
					</div> <!-- // .navi -->
					<div id="sidebar-email">
						<a href="mailto:nathan.leclaire@gmail.com">nathan.leclaire@gmail.com</a>
					</div>
				</header>
				<span id="shameless-self-promotion">
				<!-- Begin MailChimp Signup Form -->

				<div id="mc_embed_signup">
				<form action="https://nathanleclaire.us3.list-manage.com/subscribe/post?u=bb81abde21debade7a3b6c8f8&amp;id=a77a90269c" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
					<label for="mce-EMAIL">Get my essays about tech delivered to your inbox</label>
					<input type="email" value="" name="EMAIL" class="email" id="mce-EMAIL" placeholder="email@domain.com" required>
					<input type="submit" value="Go" name="subscribe" id="mc-embedded-subscribe" class="button">
					<!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
				    <div style="position: absolute; left: -5000px;"><input type="text" name="b_bb81abde21debade7a3b6c8f8_a77a90269c" value=""></div>
				</form>
				</div>
				<!--End mc_embed_signup-->
				
				<p>Quickly search the archive:</p>
				<input type="text" placeholder="Fuzzy search by keyword (e.g. Angular)" id="archive-search">
				<img src="/images/magnifying-glass.png" id="search-icon" />
				<ul id="archive-search-populate">
				</ul>
				
				</span>
			</div>
			<div id="content">
				<!-- START OF _layouts/post.html -->

<!-- START OF _includes/article.html -->
<article>
    <header>
        <h1>
            <a href="/blog/2014/02/21/how-to-wait-for-all-goroutines-to-finish-executing-before-continuing-part-two-fixing-my-ooops/">How to Wait for All Goroutines to Finish Executing Before Continuing, Part Two:  Fixing My Oops</a>
        </h1>
        <h3 style="text-align: center;">by Nathan LeClaire</h3>
        <time>21 February 2014</time>
    </header>
    <div>
        <p>Earlier this week I published an article called <a href="http://nathanleclaire.com/blog/2014/02/15/how-to-wait-for-all-goroutines-to-finish-executing-before-continuing/">How To Wait for All Goroutines to Finish Executing Before Continuing</a> detailing a problem that I'd run into while coding with Golang and the solution that I'd encountered, which was to use <a href="http://golang.org/pkg/sync/#WaitGroup">sync.WaitGroup</a>.  I was still basking a little in that I-just-finished-a-new-blog-article afterglow when something in the <a href="http://www.reddit.com/r/golang/comments/1y3spq/how_to_wait_for_all_goroutines_to_finish/">Reddit comments</a> caught my eye!</p>

<p><img src="/images/syncwaitgroup2/enneff_speaks.jpeg" title="Oh." ></p>

<p>Turns out that my approach in the previous article causes a race condition.  So, just so you guys are all aware, I was wrong, and here's why.</p>

<h1>What was wrong</h1>

<p>As <a href="http://reddit.com/u/enneff">/u/enneff</a> pointed out, there are a variety of issues with the examples I provided.</p>

<h2>What was wrong with the "Old-School way" code?</h2>

<p>I'll start at the second example (The "Old-School" way) since the first example is REALLY bad by design (please don't write Go like that).  I used a "done" channel to communicate the status of the goroutines, and it turns out that this was completely unneccsary.</p>

<p>The original code:</p>

<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span></span></figcaption><pre class=go><code>package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() {
    messages := make(chan int)

    // Use this channel to follow the execution status
    // of our goroutines :D
    done := make(chan bool)

    go func() {
        time.Sleep(time.Second * 3)
        messages &lt;- 1
        done &lt;- true
    }()
    go func() {
        time.Sleep(time.Second * 2)
        messages &lt;- 2
        done &lt;- true
    }() 
    go func() {
        time.Sleep(time.Second * 1)
        messages &lt;- 3
        done &lt;- true
    }()
    go func() {
        for i := range messages {
            fmt.Println(i)
        }
    }()
    for i := 0; i &lt; 3; i++ {
        &lt;-done
    }
}</code></pre></figure></notextile></div>


<p>Thinking about it a bit, enneff's assertion that the channel is unneeded makes a lot of sense, since you know the number of messages ahead of time.  It's a great example of how you shouldn't needlessly overcomplicate things (<a href="http://legacy.python.org/dev/peps/pep-0020/">simple is better than complex</a>).</p>

<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span></span></figcaption><pre class=go><code>package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() {
    messages := make(chan int)
    go func() {
        time.Sleep(time.Second * 3)
        messages &lt;- 1
    }()
    go func() {
        time.Sleep(time.Second * 2)
        messages &lt;- 2
    }()
    go func() {
        time.Sleep(time.Second * 1)
        messages &lt;- 3
    }()
    for i := 0; i &lt; 3; i++ {
        fmt.Println(&lt;-messages)
    }
}</code></pre></figure></notextile></div>


<p>This code is shorter, and doesn't introduce unneeded complexity.</p>

<h2>What was wrong with the "Canonical way" code?</h2>

<p>Well, for one thing, the messages channel doesn't get closed, which could cause a memory leak.  It's also not exactly cosidered the best use for a <code>WaitGroup</code>.  As enneff put it:</p>

<blockquote><p>The original program leaves the printing goroutine hanging (it blocks trying to receive a fourth message that never comes). This will create a memory leak in a long-running problem. You need to close the messages channel after the wg.Wait, to make sure that goroutine terminates. Obviously not a problem in a trivial program, but we should teach good practices at all times. But that still doesn't solve the problem of the racing and printing goroutines, and there's no reason why the so-called "old-school" way isn't appropriate here. When you know the number of messages to expect you might as well count them to know when to finish. Here the waitgroup is superfluous and confusing. WaitGroups are more useful for doing different tasks in parallel.</p></blockquote>

<p>More importantly, I mistakenly put the code to print the results in its own goroutine, which causes a race condition between the main goroutine and the goroutine that is printing.  In many cases, the main goroutine will win this race, which is BAD!!  Turns out that my whole "sleep for a few seconds, then send a message down the channel" example is actually not a good example for wait groups at all.</p>

<p>The "fetch some JSON from the Reddit API" example, however, actually is a good candidate for <code>sync.WaitGroup</code>, and enneff even featured a rewrite that takes advantage of multiple channels to send errors in case something goes wrong!</p>

<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span></span></figcaption><pre class=go><code>// This snippet was prepared in response to this article:
// http://nathanleclaire.com/blog/2014/02/15/how-to-wait-for-all-goroutines-to-finish-executing-before-continuing/
package main

import (
    &quot;fmt&quot;
    &quot;io/ioutil&quot;
    &quot;net/http&quot;
)

func main() {
    urls := []string{
        &quot;http://www.reddit.com/r/aww.json&quot;,
        &quot;http://www.reddit.com/r/funny.json&quot;,
        &quot;http://www.reddit.com/r/programming.json&quot;,
    }

    resc, errc := make(chan string), make(chan error)

    for _, url := range urls {
        go func(url string) {
            body, err := fetch(url)
            if err != nil {
                errc &lt;- err
                return
            }
            resc &lt;- string(body)
        }(url)
    }

    for i := 0; i &lt; len(urls); i++ {
        select {
        case res := &lt;-resc:
            fmt.Println(res)
        case err := &lt;-errc:
            fmt.Println(err)
        }
    }
}

func fetch(url string) (string, error) {
    res, err := http.Get(url)
    if err != nil {
        return &quot;&quot;, err
    }
    body, err := ioutil.ReadAll(res.Body)
    res.Body.Close()
    if err != nil {
        return &quot;&quot;, err
    }
    return string(body), nil
}</code></pre></figure></notextile></div>


<p>Lookin' good!</p>

<h1>Conclusion</h1>

<p>All I know is that I don't know nothing.</p>

<iframe width="420" height="315" src="//www.youtube.com/embed/5HtUnubXAO4" frameborder="0" allowfullscreen></iframe>


<p>Thanks again to <a href="https://twitter.com/enneff">Andrew Gerrand</a> for helping me to learn more about Go.  And until next time, stay sassy Internet.</p>

<ul>
<li>Nathan</li>
</ul>


    </div>
    <footer>
        <p>If you find a mistake or issue in this article, please <a id="pull-request-link" taget="_blank" href="">fix it and submit a pull request on Github</a> (must be signed in to your GitHub account).</p>
        <a target="_blank" style="display: block;" href="https://twitter.com/share?url=http://nathanleclaire.com/blog/2014/02/21/how-to-wait-for-all-goroutines-to-finish-executing-before-continuing-part-two-fixing-my-ooops/&text=Great article from @upthecyberpunks : " class="social-media-spam">Tweet It</a>
        <a target="_blank" href="https://news.ycombinator.com/submitlink?u=http://nathanleclaire.com/blog/2014/02/21/how-to-wait-for-all-goroutines-to-finish-executing-before-continuing-part-two-fixing-my-ooops/&t=" class="social-media-spam">Submit to Hacker News</a>
        <a target="_blank" style="display: block !important;" href="http://www.reddit.com/submit?url=http://nathanleclaire.com/blog/2014/02/21/how-to-wait-for-all-goroutines-to-finish-executing-before-continuing-part-two-fixing-my-ooops/&title=" class="social-media-spam">Submit to Reddit</a>
        <br>


		



  
		
			Tagged under
		
    <a class='category' href='/blog/categories/concurrency/'>concurrency</a>, <a class='category' href='/blog/categories/golang/'>golang</a>, <a class='category' href='/blog/categories/goroutines/'>goroutines</a>, <a class='category' href='/blog/categories/sync/'>sync</a>, <a class='category' href='/blog/categories/waitgroup/'>waitgroup</a>
	

 

        <a target="_blank" style="display: block !important;" href="http://discourse.nathanleclaire.com">Chat in the forum!!</a>
    
        <div id="discourse-comments"></div>
    </footer>
    
</article>
<!-- END OF _includes/article.html -->


<!-- END OF _/layouts/post.html -->

			</div>
			<form class="modal" id="mailing-list-modal" action="http://nathanleclaire.us3.list-manage.com/subscribe/post?u=bb81abde21debade7a3b6c8f8&amp;id=a77a90269c" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
					<h1>Like what you're reading?</h1>
					<img src="/images/happy-reader.jpeg"></img>
					<p style="display: block;" for="mce-EMAIL">Did you enjoy this article?  You might want to sign up for my mailing list.  I send out weekly-ish essays about hot new tech stuff.</p>
					<input type="email" value="" name="EMAIL" class="email" id="mce-EMAIL-modal" placeholder="email@domain.com" required>
					<input type="submit" value="Go" name="subscribe" id="mc-embedded-subscribe" class="button">
					<!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
				    <div style="position: absolute; left: -5000px;"><input type="text" name="b_bb81abde21debade7a3b6c8f8_a77a90269c" value=""></div>
			</form>
		</div> <!-- // .wrap -->
	<script type="text/javascript" src="/js/prettify.js"></script>
	<script>
	function supports_html5_storage() {
	  try {
		return 'localStorage' in window && window['localStorage'] !== null;
	  } catch (e) {
		return false;
	  }
	}

	$(document).ready(function () {
	    var fuse;

	    $("code").addClass("prettyprint");
	    prettyPrint();

	    $.getJSON("/articles.json", function(data) {
	    	// input:
	    	// [{title: "Learn Node.js The Troll Way", href: "blahblah"}, { ... }]
	    	fuse = new Fuse(data, {
	    	    keys: ['title', 'tags']
	    	});
	    });
	    
	    $("#archive-search").keyup(function() {
	    	var $this = $(this);
	    	var val = $this.val();
	    	var result = fuse.search(val).slice(0, 1);
	    	$list = $("#archive-search-populate");
	    	$list.empty();
	    	if (result.length > 0 && val !== '') {
	    	    $.each(result, function(i, e) {
	    	        $list.append('<li><a href="'+ e.href +'">'+ e.title +'</a></li>');
	    	    });
	    	}
	    });
	    
	    $(".social-media-spam").each(function () {
	        var e = $(this);
	        var t = e.attr("href");
	        var n = $("article header h1 a").html();
	        t += encodeURIComponent(n);
	        e.attr("href", t)
	    });

	    var e = window.location.href;
	    var t = $("#pull-request-link");
	    var n = "https://github.com/nathanleclaire/blog/edit/master/source/_posts/" + e.split("/").slice(4, 8).join("-") + ".markdown";
	    t.attr("href", n);

	    // Only offer mailing list once
		var tryModal = localStorage["modal"] ? false : true;

		// Don't offer mailing list to people on mobile
		if ($(window).width() < 720) {
			tryModal = false;
		}

		$('#mc-embedded-subscribe').click(function() {
			// Don't offer mailing list if people have
			// already clicked to try and sign up
			tryModal = false;
			localStorage["modal"] = "true";
		});

		$(window).scroll(function () {
			if (tryModal && document.URL.indexOf('archives') === -1 && document.URL.indexOf('about') === -1) {
				if (($(window).scrollTop() + $(window).height()) === $(document).height()) {
					if (supports_html5_storage()) {
						window.setTimeout(function() {
							$('#mailing-list-modal').modal({
								fadeDuration: 250
							});
							$('#mce-EMAIL-modal').focus();
							tryModal = false;
							localStorage["modal"] = "true";
						}, 1000);
					}
				}
			}
		});


	});
	</script>
	<script type="text/javascript">
	if ('/blog/2014/02/21/how-to-wait-for-all-goroutines-to-finish-executing-before-continuing-part-two-fixing-my-ooops/' !== '/blog/index.html') {
	  var discourseUrl = "http://discourse.nathanleclaire.com/",
	      discourseEmbedUrl = 'http://nathanleclaire.com/blog/2014/02/21/how-to-wait-for-all-goroutines-to-finish-executing-before-continuing-part-two-fixing-my-ooops/';

	  (function() {
	    var d = document.createElement('script'); d.type = 'text/javascript'; d.async = true;
	      d.src = discourseUrl + 'javascripts/embed.js';
	    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(d);
	  })();
	}
	</script>
	<script>
	  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
	  ga('create', 'UA-26758702-2', 'nathanleclaire.com');
	  ga('send', 'pageview');
	</script>
	</body>
</html>
<!-- END OF _layouts/default.html -->
